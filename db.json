{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/css/personal-style.css","path":"css/personal-style.css","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":1,"renderable":1},{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":1,"renderable":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":1,"renderable":1},{"_id":"themes/fexo/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/fexo/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/fexo/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":1,"renderable":1},{"_id":"themes/fexo/source/images/favicon.png","path":"images/favicon.png","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":1,"renderable":1},{"_id":"themes/fexo/source/images/bg.png","path":"images/bg.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/fexo/.csscomb.json","hash":"1705fe6d52603391eb303751f559eff72170a2a8","modified":1545927843321},{"_id":"themes/fexo/.gitignore","hash":"f6a7d23a22b644b894b6e8b644b29d24a4eef91b","modified":1545927843321},{"_id":"themes/fexo/LICENSE","hash":"254873dd0da3d669426d67f255854b3d09f4cd24","modified":1545927843321},{"_id":"themes/fexo/README.md","hash":"1c6a9a4676a3e9c66c47ad772c45c9cb435f9d25","modified":1545927843321},{"_id":"themes/fexo/_config.yml","hash":"f44368272bc521e674d99d56aa8a701d43e21b0f","modified":1545986129333},{"_id":"themes/fexo/gulpfile.js","hash":"63b37775d9f1c45c12cc35c02e25488b8a5cedc4","modified":1545927843351},{"_id":"themes/fexo/package.json","hash":"8207cbb809c18d514c700338bbb3eb983092a001","modified":1545927843431},{"_id":"source/_posts/springboot学习笔记.md","hash":"636d262986083d3a198546106d06dff7e65194d5","modified":1545988560726},{"_id":"source/_posts/死磕Mybatis.md","hash":"ce211ddb2472e617089c2d4d024aa0c25b3c8927","modified":1545988590388},{"_id":"source/_posts/死磕SpringMVC.md","hash":"505da05c467e7c8e234ff422680857234a582e4a","modified":1545988602268},{"_id":"source/_posts/死磕java基础.md","hash":"46bbb5a7af9796a4434fa638598455eaa021f51c","modified":1545988578480},{"_id":"source/guestbook/index.md","hash":"61ec7813dd2f83571dfb382578b65cf506c41691","modified":1545985708259},{"_id":"source/category/index.md","hash":"2c5f75543c6d58989a64f05187f30513e9d6d918","modified":1545983524812},{"_id":"source/about/index.md","hash":"cf13fa2a2c235d72f5bf4f12882ca6d59e73c3c5","modified":1545983619002},{"_id":"source/search/index.md","hash":"36d0c2c812e3098d3163b4c04ef1d41091a31b3c","modified":1545983675793},{"_id":"source/tag/index.md","hash":"e7093b357e803084f09686edabf6aa301828374c","modified":1545983916945},{"_id":"themes/fexo/languages/default.yml","hash":"8024ae389a371b88ba2200199d148cb85441e22b","modified":1545927843351},{"_id":"themes/fexo/languages/en.yml","hash":"46409ca1352107db0d12e3620649f50dab89c1f9","modified":1545927843351},{"_id":"themes/fexo/languages/zh-CN.yml","hash":"8024ae389a371b88ba2200199d148cb85441e22b","modified":1545927843351},{"_id":"themes/fexo/languages/no.yml","hash":"d9a1b34d590f94ab5c03809754e62bc4cf0e8d0f","modified":1545927843351},{"_id":"themes/fexo/languages/zh-TW.yml","hash":"b2474b775a8fa0fa3e9e3c58ddb11b20cf65dbc5","modified":1545927843351},{"_id":"themes/fexo/layout/about.ejs","hash":"2da014491a3d4c99f0d1f8d4234792bdbdaeb0a8","modified":1545927843411},{"_id":"themes/fexo/layout/index.ejs","hash":"ee3fbfb2f560b3fb1ef074fd2912d759702e4e0f","modified":1545927843431},{"_id":"themes/fexo/layout/layout.ejs","hash":"55bb1a65cca87379c306113b481c7cc5a1e48525","modified":1545927843431},{"_id":"themes/fexo/layout/archive.ejs","hash":"1c841544a653ca622f2a4c694f9d6cff75df94a4","modified":1545927843421},{"_id":"themes/fexo/layout/post.ejs","hash":"c151be598d176a8a25d1f9987a0c1bbb443a851b","modified":1545927843431},{"_id":"themes/fexo/layout/category.ejs","hash":"a9216a0229dadfef656bb0c91fa7abba72865d5f","modified":1545927843421},{"_id":"themes/fexo/layout/search.ejs","hash":"9f52f953d161cb1ea3fd9f8a502c74e0ad5a57bd","modified":1545927843431},{"_id":"themes/fexo/layout/link.ejs","hash":"f6f3ef389fee05013e77c0acef71ac3fa3cc7103","modified":1545927843431},{"_id":"themes/fexo/layout/project.ejs","hash":"515621da8d0be8c2de4ea34e63b583f14bc6c6e0","modified":1545927843431},{"_id":"themes/fexo/layout/tag.ejs","hash":"1fb070d4fedc855c7931889b40bff95b5d95286a","modified":1545927843431},{"_id":"themes/fexo/yarn.lock","hash":"241b66962a690830817bdffd9759b8a570da9f5d","modified":1545927843561},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","hash":"19a0ae26e336a0f5f475d231e4984eb891bd1022","modified":1545927843351},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","hash":"3801a22d0bfe46c118a4ce5187e22121ba02ff7f","modified":1545927843361},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1545927843411},{"_id":"themes/fexo/layout/_partial/article.ejs","hash":"f75505424d4f3b6bcf49624b2fbeeaa2aff6db42","modified":1545927843351},{"_id":"themes/fexo/layout/_partial/head.ejs","hash":"f442f9d25b342812e7ac70bc850b6cf3ac899e93","modified":1545927843411},{"_id":"themes/fexo/layout/_partial/load-script.ejs","hash":"df9630121a1354e864d3f305744a85c8e4941517","modified":1545927843411},{"_id":"themes/fexo/layout/_partial/home.ejs","hash":"00282a39ed0f22a38b55cedc443bd57c8fa3aceb","modified":1545927843411},{"_id":"themes/fexo/layout/_partial/style.ejs","hash":"7a9211cc0a45bd2c2861043c7e4e191706cf5214","modified":1545927843411},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1545927843481},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1545927843481},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1545927843481},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1545927843481},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1545927843491},{"_id":"themes/fexo/source/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1545927843491},{"_id":"themes/fexo/source/fonts/fontello.svg","hash":"c32ea33c25a9aee152a27ea90eafb237cbdac0ca","modified":1545927843491},{"_id":"themes/fexo/source/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1545927843501},{"_id":"themes/fexo/source/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1545927843501},{"_id":"themes/fexo/source/css/personal-style.css","hash":"1dc615c0751bad626b876b95ba9c1c6eedefd358","modified":1545985692907},{"_id":"themes/fexo/source/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1545927843501},{"_id":"themes/fexo/source/css/styles.css","hash":"27a7fa2784b509de3c5329feab293321c6197024","modified":1545927843441},{"_id":"themes/fexo/source/images/avatar.jpg","hash":"06b315b1cde634d2313044a83c40b1ac10961134","modified":1545927843501},{"_id":"themes/fexo/source/sass/_animate.scss","hash":"7d7653e77750645a424d5a7ecbe59f9f7457287b","modified":1545927843521},{"_id":"themes/fexo/source/sass/_base.scss","hash":"e2597f745ee5d92ba4ef1d98cf720d7f28588428","modified":1545927843521},{"_id":"themes/fexo/source/sass/_common.scss","hash":"2b2eb1f34d839b8a75ed3c4360fa0c7776917653","modified":1545927843521},{"_id":"themes/fexo/source/sass/_fontello.scss","hash":"0a9332dd83ab64487846f7749801c8d6e104d014","modified":1545927843521},{"_id":"themes/fexo/source/sass/_fonts.scss","hash":"74a9e7653ad628199349d7cc0ec9315194ac3691","modified":1545927843521},{"_id":"themes/fexo/source/sass/_highlight-js.scss","hash":"4b6cf6478cdfeb4baa5def1f2116d36ac7100cad","modified":1545927843521},{"_id":"themes/fexo/source/sass/_normalize.scss","hash":"f466245d5ad990c1062481c0e1f8741fb4bfa00e","modified":1545927843521},{"_id":"themes/fexo/source/sass/_type.scss","hash":"f78d73bed280361c527e6111fcd0734431a60031","modified":1545927843521},{"_id":"themes/fexo/source/sass/styles.scss","hash":"7d890fc68d4e7d8fa9bb402d7b9ad9f8bbe21460","modified":1545927843561},{"_id":"themes/fexo/source/sass/_variable.scss","hash":"d16ea71577be84049c3cf006818edb94e3e1e0c5","modified":1545927843531},{"_id":"themes/fexo/source/js/app.js","hash":"39ffc133b6104bb3cb8207ce21acf5bae97e756e","modified":1545927843511},{"_id":"themes/fexo/source/js/bundle.js","hash":"8b64dd44eec4521f554323fc0a1dbb07f61dc678","modified":1545927843511},{"_id":"themes/fexo/source/js/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1545927843511},{"_id":"themes/fexo/source/js/zenscroll.js","hash":"51e88227a98123246f35a49ec22263973cec8d78","modified":1545927843521},{"_id":"themes/fexo/source/js/scroll-spy.js","hash":"5ae67d88f0147937c847bb205acae060c4f24de5","modified":1545927843511},{"_id":"themes/fexo/source/js/util.js","hash":"a7159ca12fe86bbd41b95aed2021c42884aa4676","modified":1545927843511},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1545927843491},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1545927843491},{"_id":"themes/fexo/source/css/styles.css.map","hash":"9672a4e5f8c6e9742095c1ca33f1c68b3145a7e3","modified":1545927843441},{"_id":"themes/fexo/source/images/alipay.jpg","hash":"672a43cfb35f6f1fc5afcc0db431871fb83d7d4b","modified":1545927843501},{"_id":"themes/fexo/source/images/avatar.png","hash":"7ac772678ff9f48b17906ef288ff0e3b8cf2b21a","modified":1545927843501},{"_id":"themes/fexo/source/images/wechatpay.jpg","hash":"876bbcc6f4de7c0d76adeb45260e6cbb7b67299d","modified":1545927843511},{"_id":"themes/fexo/source/sass/pages/_tag.scss","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545927843561},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","hash":"8dfc6eb4b1da4f3375b6d6cf7806dd10bc86baf3","modified":1545927843361},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","hash":"fa891596043765893fceb83978e5f85e01e6a8c4","modified":1545927843361},{"_id":"themes/fexo/layout/_partial/component/category.ejs","hash":"75434cd1cdf23fce3013e1649df684815f8f7e83","modified":1545927843361},{"_id":"themes/fexo/layout/_partial/component/changyan.ejs","hash":"c3a8bfce7fe3b3df8a3b502fcd5bf1c8e75b401f","modified":1545927843381},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","hash":"5301724e992579dd2afffd5ea07071bbe2b4ce14","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/date.ejs","hash":"517719b3c97d470c2b9211f757fc50384b21dfd3","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","hash":"1c9cf3fd62911404694704fe810684c797dfb64c","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","hash":"10565634d704f797726afca1aafd04c7ebdfe44d","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","hash":"42c1359fb919518deaa6421eb03f979258e59262","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","hash":"a17a7a8d37f57d62d85c31e364090853e661a1ba","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/gitment.ejs","hash":"79252b25c2be88219037b255c1fc90f6f46966f5","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/gitalk.ejs","hash":"d7973be1eee8c4f3181617aa7efc95db8db0f816","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","hash":"8940e9542f5b9fe599a31b0f20d3f6987928672b","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/hypercomments.ejs","hash":"872a23d69cbe8f469dc3371bdbc28f3af40f12cb","modified":1545927843391},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","hash":"fb7bb83bb70e8fdba4ff94bc413c641196f474f9","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","hash":"4abef5751ea068c3b12ad2ffbc96b7b70f23d2cd","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","hash":"64c9292926391920901cf04f4f1f5aa41fb872d7","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","hash":"366edcd8af0c1449fb6a57aea1f81111752e1f41","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","hash":"c779f82f764d6ce2285043e9797992ebb7160cd1","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","hash":"292a11a47e751b8cfdb9ff85fd23ceb3b75fd30e","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","hash":"3441860e795b275804bd109615d79d52ce0415f7","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","hash":"05d0e5182f5b622393d408fc85c64c886999eb36","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/title.ejs","hash":"713cb479e20e6843095fb23db5213c66d2259a84","modified":1545927843401},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","hash":"cad46d32d7167a4e2e6231567d5fa7668658ee65","modified":1545927843411},{"_id":"themes/fexo/layout/_partial/component/uyan.ejs","hash":"afe757c6f45d24640b22d90db6f2799000c6f994","modified":1545927843411},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","hash":"9c5de565ca94666126fc88fc52fc24f5eb4654c7","modified":1545927843411},{"_id":"themes/fexo/layout/_partial/component/valine.ejs","hash":"19f3cdc85cd44652be41ef9b1fcd6956230d9d14","modified":1545927843411},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1545927843481},{"_id":"themes/fexo/source/images/favicon.png","hash":"d42970dc107c7538ae43f6464c78a4f1c21bccd1","modified":1545927843511},{"_id":"themes/fexo/source/sass/component/_comments.scss","hash":"3e1161b25336bf974e22df15c4e574e3ac1960f6","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_back-top.scss","hash":"fadf3d3987eeee78b5c9ebbad00e6bb056429563","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_index.scss","hash":"96b7fc78bf9ca5397dd73ab1351823df605a92c7","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_category-box.scss","hash":"50825816e002fcbbfcea4788045ecf655070f1cf","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_donation.scss","hash":"e2be24eccf94dfed2b2bd7da6c8fbeb5475c8116","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","hash":"0422c181d03081c9bd870756f78c1dc97a77bd09","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_item-title.scss","hash":"cae94fbf485b6570a5cb7821da0e296d29b5919c","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_item-year.scss","hash":"4a85b4fb8f7a879ee6fdb949465697b32406ff92","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_list-post.scss","hash":"97f153db29496f6c3c8853e522a7bd3d4c0d34a7","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_hint.scss","hash":"dd8e7ac2f17a44c7dff4347290235c621d5b0776","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_item-post.scss","hash":"5ffda36360fd42c85806131f6f8bcb7b701b701c","modified":1545927843531},{"_id":"themes/fexo/source/sass/component/_modal.scss","hash":"7d4463b9d28525455aa09064d2e95b6ec6b38762","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_table.scss","hash":"ae548d0a21c5358607f3bf187c01d48c7d08531e","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_page-header.scss","hash":"5ecd7e742109acebc84e0bf612d890ff7198b4c9","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_pagination.scss","hash":"22442610082db7748ed845b2da4ad8defcc70542","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_prev-net.scss","hash":"a510a5220205904f74865e297327fa4770427db7","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","hash":"b59636ae0f5ac6d4a0fc95f5140ab7cc69b8eff5","modified":1545927843551},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","hash":"2f033e2b35c96adda32bce15b6c33f9eebcaa847","modified":1545927843541},{"_id":"themes/fexo/source/sass/component/_toc.scss","hash":"16ebf02f4b371d9a833dc002e9354a40980e6b39","modified":1545927843541},{"_id":"themes/fexo/source/sass/pages/_archive.scss","hash":"723062e099a67565c87c54e912cff1102d453d0b","modified":1545927843551},{"_id":"themes/fexo/source/sass/pages/_category.scss","hash":"3b2c188c43fd4b908e0905f5ea9b6fef9edf598e","modified":1545927843551},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","hash":"21665610ca4212def73b767f4efbe2ff48dd491e","modified":1545927843551},{"_id":"themes/fexo/source/sass/pages/_index.scss","hash":"fe46ce0d24d17aa5ac39997b9bbef5324eac9aee","modified":1545927843551},{"_id":"themes/fexo/source/sass/pages/_about.scss","hash":"47f3bf8f2c7b690f343d13dfdb6d0a1797d77833","modified":1545927843551},{"_id":"themes/fexo/source/sass/pages/_home.scss","hash":"32b68b8779e7a010051a631aebbd92b1c86bfc6d","modified":1545927843551},{"_id":"themes/fexo/source/sass/pages/_link.scss","hash":"3a29191bed2c471e05e6ef21d74f769e23192cd1","modified":1545927843551},{"_id":"themes/fexo/source/sass/pages/_post.scss","hash":"17190026311a972f34847877212577e9af90aad6","modified":1545927843551},{"_id":"themes/fexo/source/sass/pages/_project.scss","hash":"6b602e0fc5fff2e4b295eca9fd5c82794733cf3f","modified":1545927843561},{"_id":"themes/fexo/source/sass/pages/_search.scss","hash":"fd477d09e9eca14416cd03e6312ddccaa4c46689","modified":1545927843561},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","hash":"3f1f4e7974e2cff38f52daf44697048c3c4492fe","modified":1545927843491},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1545927843451},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1545927843471},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1545927843481},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1545927843471},{"_id":"themes/fexo/source/images/bg.png","hash":"d6f9c45a4353fcd27fa3881d221bdb98c00afe0c","modified":1545981327338}],"Category":[{"name":"技术","_id":"cjq7zalca0004oos245ke5ise"}],"Data":[],"Page":[{"title":"留言板","comments":1,"reward":false,"layout":"post","abbrlink":"c0297c2d","date":"2018-12-23T02:02:05.000Z","_content":"\n\n\n<center><strong>如果你正在找写留言的地，在这里写就对了 </strong></center>\n\n\n\n米＾－＾米\n","source":"guestbook/index.md","raw":"---\ntitle: 留言板\ncomments: true\nreward: false\nlayout: post\nabbrlink: c0297c2d\ndate: 2018-12-23 10:02:05\n---\n\n\n\n<center><strong>如果你正在找写留言的地，在这里写就对了 </strong></center>\n\n\n\n米＾－＾米\n","updated":"2018-12-28T08:28:28.259Z","path":"guestbook/index.html","_id":"cjq7zalc30001oos2r5tu96ai","content":"<center><strong>如果你正在找写留言的地，在这里写就对了 </strong></center>\n\n\n\n<p>米＾－＾米</p>\n","site":{"data":{}},"excerpt":"","more":"<center><strong>如果你正在找写留言的地，在这里写就对了 </strong></center>\n\n\n\n<p>米＾－＾米</p>\n"},{"title":"category","date":"2018-12-28T07:51:04.000Z","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle: category\ndate: 2018-12-28 15:51:04\nlayout: category\ncomments: false\n---\n","updated":"2018-12-28T07:52:04.812Z","path":"category/index.html","_id":"cjq7zalc80003oos2z8hd1jpb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2018-12-28T07:53:16.000Z","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-12-28 15:53:16\nlayout: about\ncomments: false\n---\n","updated":"2018-12-28T07:53:39.002Z","path":"about/index.html","_id":"cjq7zalcg0007oos295bpze94","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"search","date":"2018-12-28T07:54:11.000Z","layout":"search","comments":0,"_content":"","source":"search/index.md","raw":"---\ntitle: search\ndate: 2018-12-28 15:54:11\nlayout: search\ncomments: false\n---\n","updated":"2018-12-28T07:54:35.793Z","path":"search/index.html","_id":"cjq7zalcj0008oos2h5oliywg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tag","date":"2018-12-28T07:52:24.000Z","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\ndate: 2018-12-28 15:52:24\nlayout: tag\ncomments: false\n---\n","updated":"2018-12-28T07:58:36.945Z","path":"tag/index.html","_id":"cjq7zalcm000boos2iu6xch65","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"死磕Mybatis","comments":0,"reward":true,"toc":true,"copyright":true,"abbrlink":"b3def48c","date":"2018-12-26T16:07:45.000Z","top":null,"_content":"\n### ORM模型\n\n> ORM模型就是数据库的表和Java对象（Plan Ordinary Java Object，简称POJO）的映射关系模型\n\n### SQL和HQL\n\n> SQL语言（Structured Query Language）、HQL语言（Hibernate Query Language）\n\n### Hibernate\n\n> Hibernate是全表映射框架\n>\n> - Hibernate的缺点：\n>   1. 全表映射带来的不便，比如更新时需要发送所有字段。\n>   2. 无法根据不同条件组装不同的SQL。\n>   3. 对多表关联和复杂SQL查询支持较差，需要自己写SQL，返回后，需要自己将数据封装为POJO。\n>   4. 不能有效支持存储过程。\n>   5. 虽然有HQL，但是性能较差。大型互联网系统往往需要优化SQL，而Hibernate做不到。\n\n<!--more-->\n\n### Mybatis\n\n> Mybatis是一个半自动映射框架，之所以是半自动，是因为它需要手动匹配提供POJO、SQL和映射关系。","source":"_posts/死磕Mybatis.md","raw":"---\ntitle: 死磕Mybatis\ncomments: false\nreward: true\ntoc: true\ncopyright: true\ntags: mybatis\ncategories: 技术\nabbrlink: b3def48c\ndate: 2018-12-27 00:07:45\ntop:\n---\n\n### ORM模型\n\n> ORM模型就是数据库的表和Java对象（Plan Ordinary Java Object，简称POJO）的映射关系模型\n\n### SQL和HQL\n\n> SQL语言（Structured Query Language）、HQL语言（Hibernate Query Language）\n\n### Hibernate\n\n> Hibernate是全表映射框架\n>\n> - Hibernate的缺点：\n>   1. 全表映射带来的不便，比如更新时需要发送所有字段。\n>   2. 无法根据不同条件组装不同的SQL。\n>   3. 对多表关联和复杂SQL查询支持较差，需要自己写SQL，返回后，需要自己将数据封装为POJO。\n>   4. 不能有效支持存储过程。\n>   5. 虽然有HQL，但是性能较差。大型互联网系统往往需要优化SQL，而Hibernate做不到。\n\n<!--more-->\n\n### Mybatis\n\n> Mybatis是一个半自动映射框架，之所以是半自动，是因为它需要手动匹配提供POJO、SQL和映射关系。","slug":"死磕Mybatis","published":1,"updated":"2018-12-28T09:16:30.388Z","layout":"post","photos":[],"link":"","_id":"cjq7zalbv0000oos22002xb8f","content":"<h3 id=\"ORM模型\"><a href=\"#ORM模型\" class=\"headerlink\" title=\"ORM模型\"></a>ORM模型</h3><blockquote>\n<p>ORM模型就是数据库的表和Java对象（Plan Ordinary Java Object，简称POJO）的映射关系模型</p>\n</blockquote>\n<h3 id=\"SQL和HQL\"><a href=\"#SQL和HQL\" class=\"headerlink\" title=\"SQL和HQL\"></a>SQL和HQL</h3><blockquote>\n<p>SQL语言（Structured Query Language）、HQL语言（Hibernate Query Language）</p>\n</blockquote>\n<h3 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h3><blockquote>\n<p>Hibernate是全表映射框架</p>\n<ul>\n<li>Hibernate的缺点：<ol>\n<li>全表映射带来的不便，比如更新时需要发送所有字段。</li>\n<li>无法根据不同条件组装不同的SQL。</li>\n<li>对多表关联和复杂SQL查询支持较差，需要自己写SQL，返回后，需要自己将数据封装为POJO。</li>\n<li>不能有效支持存储过程。</li>\n<li>虽然有HQL，但是性能较差。大型互联网系统往往需要优化SQL，而Hibernate做不到。</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h3><blockquote>\n<p>Mybatis是一个半自动映射框架，之所以是半自动，是因为它需要手动匹配提供POJO、SQL和映射关系。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"ORM模型\"><a href=\"#ORM模型\" class=\"headerlink\" title=\"ORM模型\"></a>ORM模型</h3><blockquote>\n<p>ORM模型就是数据库的表和Java对象（Plan Ordinary Java Object，简称POJO）的映射关系模型</p>\n</blockquote>\n<h3 id=\"SQL和HQL\"><a href=\"#SQL和HQL\" class=\"headerlink\" title=\"SQL和HQL\"></a>SQL和HQL</h3><blockquote>\n<p>SQL语言（Structured Query Language）、HQL语言（Hibernate Query Language）</p>\n</blockquote>\n<h3 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h3><blockquote>\n<p>Hibernate是全表映射框架</p>\n<ul>\n<li>Hibernate的缺点：<ol>\n<li>全表映射带来的不便，比如更新时需要发送所有字段。</li>\n<li>无法根据不同条件组装不同的SQL。</li>\n<li>对多表关联和复杂SQL查询支持较差，需要自己写SQL，返回后，需要自己将数据封装为POJO。</li>\n<li>不能有效支持存储过程。</li>\n<li>虽然有HQL，但是性能较差。大型互联网系统往往需要优化SQL，而Hibernate做不到。</li>\n</ol>\n</li>\n</ul>\n</blockquote>","more":"<h3 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h3><blockquote>\n<p>Mybatis是一个半自动映射框架，之所以是半自动，是因为它需要手动匹配提供POJO、SQL和映射关系。</p>\n</blockquote>"},{"title":"死磕SpringMVC","comments":0,"reward":true,"toc":true,"copyright":true,"abbrlink":"7bb1067a","date":"2018-12-26T16:09:00.000Z","top":null,"_content":"\n# 1. Spring中的注解及应用\n\n## 1. @Controller\n\n> 标识一个该类是SpringMVC Controller处理类，用来处理http请求对象\n\n```java\n@Controller\npublic class TestController{\n    @RequestMapping(\"/index\",method=Request.GET)\n    public String index(Map<String,Object>map){\n        return \"Hello World!\";\n    }\n}\n```\n<!--more-->\n\n## 2. @RestController\n\n> 在spring4.x之前没加入@RestController之前，@Controller要返回Json数据需要@RequestBody来配合，如果用@RestController代替@Controller，就不需要配置@RequestBody。默认返回Json。\n\n```java\n@RestController\npublic class TestController{\n    @RequestMapping(\"/index\",method=Request.GET)\n    public String index(Map<String,Object>map){\n        return \"Hello World!\";\n    }\n}\n```\n\n## 3. @Service\n\n> 用于标注业务层组件，加入该注解把这个类加入到Spring的配置中去\n\n## 4. AutoWired\n\n> 用来装配Bean，可以写在字段上或者方法上，默认情况下要求被依赖对象必须存在，如果允许为null，可以设置它的required属性为false，例如：@AutoWired(Required=false)\n\n## 5. @RequestMapping\n\n> 类定义处：提供初步的请求映射信息，相对于WEB根目录。\n>\n> 方法处：提供进一步的细分映射信息，相对于类定义处的URL。\n\n## 6. @RequestParam\n\n> 用于将请求参数区的数据映射到功能处理方法 的参数上。\n\n```java\npublic Resp test(@RequestParam Integer id){\n    return Resp.success(customerInfoService.fetch(id));\n}\n```\n\n这个id就是要接收 从接口传递过来的id的值的，如果传递过来的参数名和接收的不一致，可以如下：\n\n```java\npublic Resp test(@RequestParam(value=\"course_id\" Integer id)){\n    return Resp.success(customerInfoService.fetch(id));\n}\n```\n\n其中course_id就是接口传递的参数，id就是映射course_id的参数名。\n\n## 7. @ModelAttribute\n\n使用地方有三种：\n\n1. 标记在方法上\n\n> 标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。\n\n- 在有返回值的方法上\n\n当ModelAttribute设置了value，方法返回的值会以这个value为key，以接收到的值作为value，存入到Model中，如下面的方法执行后，最总相当于model.addAttribute(\"username\",name)；假如@ModelAttribute没有自定义设置value，则相当于：\n\nmodel.addAttribute(\"name\",name);\n\n```java\n@ModelAttribute(value=\"user_name\")\npublic String before(@RequestParam(required=false)String name,Model model){\n    System.out.println(\"进入：\"+name);\n    return \"name\";\n}\n```\n\n2. 在没有返回的方法上\n\n> 需要手动model.add方法\n\n```java\n@ModelAttribute\npublic void before(@RequestParam(required=false,Integer age,Model model)){\n    model.addAttribute(\"age\",age);\n    System.out.println(\"进入：\"+age);\n}\n```\n\n新建请求方法：\n\n```java\n@RequestMapping(\"/mod\")\npublic Resp mod(@RequestParam(required=false)String name,\n               @RequestParam(required=false)Integer age,Model model){\n    System.out.println(\"进入mod\");\n    return Resp.success(\"1\");\n}\n```\n\n在浏览器中输入访问地址并加上参数：\n\n``` http\nhttp://localhost:8081/api/test/mod?name=我是小菜&age=12\n```\n\n最终输出结果如下：\n\n```\n进入了1：40\n进入了2：我是小菜\n进入mod\n参数接受的数值{name=我是小菜;age=12}\nmodel传过来的值:{age=40, user_name=我是小菜}\n```\n\n2. 标记在方法的参数上\n\n> 标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于view层使用。\n\n```java\n @RequestMapping(value=\"/mod2\")\n  public Resp mod2(@ModelAttribute(\"user_name\") String user_name,   @ModelAttribute(\"name\") String name, @ModelAttribute(\"age\") Integer age,Model model){ \n      System.out.println(\"进入mod2\"); \n      System.out.println(\"user_name:\"+user_name); \n      System.out.println(\"name：\"+name);\n      System.out.println(\"age:\"+age); \n      System.out.println(\"model:\"+model);   \n      return Resp.success(\"1\");   \n      }\n```\n\n在浏览器中输入访问地址并且加上参数：\n\n```http\nhttp://localhost:8081/api/test/mod2?name=我是小菜&age=12\n```\n\n最终输出：\n\n```c\n1进入了1：402进入了\n2：我是小菜\n3进入mod2\n4user_name:我是小菜\n5name：我是小菜\n6age:40\n7model:{user_name=我是小菜, org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, age=40, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: 0 errors}\n```\n\n从结果就能看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。\n\n## 8. @Cacheable\n\n用于标记缓存查询，可用于方法或者类中，\n\n> 当标记在一个方法上时表示该方法是支持缓存的\n>\n> 当标记在一个类上时表示该类的所有方法都是支持缓存的\n\n参数列表\n\n| 参数      | 解释 | 例子                                    |\n| --------- | ---- | --------------------------------------- |\n| value     | 名称 | @Cacheable(value={\"c1\",\"c2\"})           |\n| key       | key  | @Cacheable(value=\"c1\",key=\"#id\")        |\n| condition | 条件 | @Cacheable(value=\"1\",condition=\"#id=1\") |\n\n比如@Cacheable(value=\"UserCache\") 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。\n但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义.\n\n```java\n@Cacheable(value=\"UserCache\") //使用了一个缓存，名叫UserCache\npublic Account getUserAge(int id){\n    //这里不用写缓存逻辑，直接按正常业务走即可\n    //缓存通过切面自动切入\n    int age=getUser(id);\n    return age;\n}\n```\n\n## 9. @CacheEvict\n\n用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。\n\n@CacheEvict(value=\"UserCache\")\n\n**参数列表**","source":"_posts/死磕SpringMVC.md","raw":"---\ntitle: 死磕SpringMVC\ncomments: false\nreward: true\ntoc: true\ncopyright: true\ntags: springmvc\ncategories: 技术\nabbrlink: 7bb1067a\ndate: 2018-12-27 00:09:00\ntop:\n---\n\n# 1. Spring中的注解及应用\n\n## 1. @Controller\n\n> 标识一个该类是SpringMVC Controller处理类，用来处理http请求对象\n\n```java\n@Controller\npublic class TestController{\n    @RequestMapping(\"/index\",method=Request.GET)\n    public String index(Map<String,Object>map){\n        return \"Hello World!\";\n    }\n}\n```\n<!--more-->\n\n## 2. @RestController\n\n> 在spring4.x之前没加入@RestController之前，@Controller要返回Json数据需要@RequestBody来配合，如果用@RestController代替@Controller，就不需要配置@RequestBody。默认返回Json。\n\n```java\n@RestController\npublic class TestController{\n    @RequestMapping(\"/index\",method=Request.GET)\n    public String index(Map<String,Object>map){\n        return \"Hello World!\";\n    }\n}\n```\n\n## 3. @Service\n\n> 用于标注业务层组件，加入该注解把这个类加入到Spring的配置中去\n\n## 4. AutoWired\n\n> 用来装配Bean，可以写在字段上或者方法上，默认情况下要求被依赖对象必须存在，如果允许为null，可以设置它的required属性为false，例如：@AutoWired(Required=false)\n\n## 5. @RequestMapping\n\n> 类定义处：提供初步的请求映射信息，相对于WEB根目录。\n>\n> 方法处：提供进一步的细分映射信息，相对于类定义处的URL。\n\n## 6. @RequestParam\n\n> 用于将请求参数区的数据映射到功能处理方法 的参数上。\n\n```java\npublic Resp test(@RequestParam Integer id){\n    return Resp.success(customerInfoService.fetch(id));\n}\n```\n\n这个id就是要接收 从接口传递过来的id的值的，如果传递过来的参数名和接收的不一致，可以如下：\n\n```java\npublic Resp test(@RequestParam(value=\"course_id\" Integer id)){\n    return Resp.success(customerInfoService.fetch(id));\n}\n```\n\n其中course_id就是接口传递的参数，id就是映射course_id的参数名。\n\n## 7. @ModelAttribute\n\n使用地方有三种：\n\n1. 标记在方法上\n\n> 标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。\n\n- 在有返回值的方法上\n\n当ModelAttribute设置了value，方法返回的值会以这个value为key，以接收到的值作为value，存入到Model中，如下面的方法执行后，最总相当于model.addAttribute(\"username\",name)；假如@ModelAttribute没有自定义设置value，则相当于：\n\nmodel.addAttribute(\"name\",name);\n\n```java\n@ModelAttribute(value=\"user_name\")\npublic String before(@RequestParam(required=false)String name,Model model){\n    System.out.println(\"进入：\"+name);\n    return \"name\";\n}\n```\n\n2. 在没有返回的方法上\n\n> 需要手动model.add方法\n\n```java\n@ModelAttribute\npublic void before(@RequestParam(required=false,Integer age,Model model)){\n    model.addAttribute(\"age\",age);\n    System.out.println(\"进入：\"+age);\n}\n```\n\n新建请求方法：\n\n```java\n@RequestMapping(\"/mod\")\npublic Resp mod(@RequestParam(required=false)String name,\n               @RequestParam(required=false)Integer age,Model model){\n    System.out.println(\"进入mod\");\n    return Resp.success(\"1\");\n}\n```\n\n在浏览器中输入访问地址并加上参数：\n\n``` http\nhttp://localhost:8081/api/test/mod?name=我是小菜&age=12\n```\n\n最终输出结果如下：\n\n```\n进入了1：40\n进入了2：我是小菜\n进入mod\n参数接受的数值{name=我是小菜;age=12}\nmodel传过来的值:{age=40, user_name=我是小菜}\n```\n\n2. 标记在方法的参数上\n\n> 标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于view层使用。\n\n```java\n @RequestMapping(value=\"/mod2\")\n  public Resp mod2(@ModelAttribute(\"user_name\") String user_name,   @ModelAttribute(\"name\") String name, @ModelAttribute(\"age\") Integer age,Model model){ \n      System.out.println(\"进入mod2\"); \n      System.out.println(\"user_name:\"+user_name); \n      System.out.println(\"name：\"+name);\n      System.out.println(\"age:\"+age); \n      System.out.println(\"model:\"+model);   \n      return Resp.success(\"1\");   \n      }\n```\n\n在浏览器中输入访问地址并且加上参数：\n\n```http\nhttp://localhost:8081/api/test/mod2?name=我是小菜&age=12\n```\n\n最终输出：\n\n```c\n1进入了1：402进入了\n2：我是小菜\n3进入mod2\n4user_name:我是小菜\n5name：我是小菜\n6age:40\n7model:{user_name=我是小菜, org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, age=40, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: 0 errors}\n```\n\n从结果就能看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。\n\n## 8. @Cacheable\n\n用于标记缓存查询，可用于方法或者类中，\n\n> 当标记在一个方法上时表示该方法是支持缓存的\n>\n> 当标记在一个类上时表示该类的所有方法都是支持缓存的\n\n参数列表\n\n| 参数      | 解释 | 例子                                    |\n| --------- | ---- | --------------------------------------- |\n| value     | 名称 | @Cacheable(value={\"c1\",\"c2\"})           |\n| key       | key  | @Cacheable(value=\"c1\",key=\"#id\")        |\n| condition | 条件 | @Cacheable(value=\"1\",condition=\"#id=1\") |\n\n比如@Cacheable(value=\"UserCache\") 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。\n但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义.\n\n```java\n@Cacheable(value=\"UserCache\") //使用了一个缓存，名叫UserCache\npublic Account getUserAge(int id){\n    //这里不用写缓存逻辑，直接按正常业务走即可\n    //缓存通过切面自动切入\n    int age=getUser(id);\n    return age;\n}\n```\n\n## 9. @CacheEvict\n\n用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。\n\n@CacheEvict(value=\"UserCache\")\n\n**参数列表**","slug":"死磕SpringMVC","published":1,"updated":"2018-12-28T09:16:42.268Z","layout":"post","photos":[],"link":"","_id":"cjq7zalc50002oos2d0o7k8kb","content":"<h1 id=\"1-Spring中的注解及应用\"><a href=\"#1-Spring中的注解及应用\" class=\"headerlink\" title=\"1. Spring中的注解及应用\"></a>1. Spring中的注解及应用</h1><h2 id=\"1-Controller\"><a href=\"#1-Controller\" class=\"headerlink\" title=\"1. @Controller\"></a>1. @Controller</h2><blockquote>\n<p>标识一个该类是SpringMVC Controller处理类，用来处理http请求对象</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/index\"</span>,method=Request.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">(Map&lt;String,Object&gt;map)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"2-RestController\"><a href=\"#2-RestController\" class=\"headerlink\" title=\"2. @RestController\"></a>2. @RestController</h2><blockquote>\n<p>在spring4.x之前没加入@RestController之前，@Controller要返回Json数据需要@RequestBody来配合，如果用@RestController代替@Controller，就不需要配置@RequestBody。默认返回Json。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/index\"</span>,method=Request.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">(Map&lt;String,Object&gt;map)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-Service\"><a href=\"#3-Service\" class=\"headerlink\" title=\"3. @Service\"></a>3. @Service</h2><blockquote>\n<p>用于标注业务层组件，加入该注解把这个类加入到Spring的配置中去</p>\n</blockquote>\n<h2 id=\"4-AutoWired\"><a href=\"#4-AutoWired\" class=\"headerlink\" title=\"4. AutoWired\"></a>4. AutoWired</h2><blockquote>\n<p>用来装配Bean，可以写在字段上或者方法上，默认情况下要求被依赖对象必须存在，如果允许为null，可以设置它的required属性为false，例如：@AutoWired(Required=false)</p>\n</blockquote>\n<h2 id=\"5-RequestMapping\"><a href=\"#5-RequestMapping\" class=\"headerlink\" title=\"5. @RequestMapping\"></a>5. @RequestMapping</h2><blockquote>\n<p>类定义处：提供初步的请求映射信息，相对于WEB根目录。</p>\n<p>方法处：提供进一步的细分映射信息，相对于类定义处的URL。</p>\n</blockquote>\n<h2 id=\"6-RequestParam\"><a href=\"#6-RequestParam\" class=\"headerlink\" title=\"6. @RequestParam\"></a>6. @RequestParam</h2><blockquote>\n<p>用于将请求参数区的数据映射到功能处理方法 的参数上。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">test</span><span class=\"params\">(@RequestParam Integer id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Resp.success(customerInfoService.fetch(id));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个id就是要接收 从接口传递过来的id的值的，如果传递过来的参数名和接收的不一致，可以如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">test</span><span class=\"params\">(@RequestParam(value=<span class=\"string\">\"course_id\"</span> Integer id)</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Resp.success(customerInfoService.fetch(id));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中course_id就是接口传递的参数，id就是映射course_id的参数名。</p>\n<h2 id=\"7-ModelAttribute\"><a href=\"#7-ModelAttribute\" class=\"headerlink\" title=\"7. @ModelAttribute\"></a>7. @ModelAttribute</h2><p>使用地方有三种：</p>\n<ol>\n<li>标记在方法上</li>\n</ol>\n<blockquote>\n<p>标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。</p>\n</blockquote>\n<ul>\n<li>在有返回值的方法上</li>\n</ul>\n<p>当ModelAttribute设置了value，方法返回的值会以这个value为key，以接收到的值作为value，存入到Model中，如下面的方法执行后，最总相当于model.addAttribute(“username”,name)；假如@ModelAttribute没有自定义设置value，则相当于：</p>\n<p>model.addAttribute(“name”,name);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ModelAttribute</span>(value=<span class=\"string\">\"user_name\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">before</span><span class=\"params\">(@RequestParam(required=<span class=\"keyword\">false</span>)</span>String name,Model model)</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"进入：\"</span>+name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"name\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在没有返回的方法上</li>\n</ol>\n<blockquote>\n<p>需要手动model.add方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ModelAttribute</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">(@RequestParam(required=<span class=\"keyword\">false</span>,Integer age,Model model)</span>)</span>&#123;</span><br><span class=\"line\">    model.addAttribute(<span class=\"string\">\"age\"</span>,age);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"进入：\"</span>+age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新建请求方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mod\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">mod</span><span class=\"params\">(@RequestParam(required=<span class=\"keyword\">false</span>)</span>String name,</span></span><br><span class=\"line\"><span class=\"function\">               @<span class=\"title\">RequestParam</span><span class=\"params\">(required=<span class=\"keyword\">false</span>)</span>Integer age,Model model)</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"进入mod\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Resp.success(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在浏览器中输入访问地址并加上参数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://localhost:8081/api/test/mod?name=我是小菜&amp;age=12</span><br></pre></td></tr></table></figure>\n<p>最终输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">进入了1：40</span><br><span class=\"line\">进入了2：我是小菜</span><br><span class=\"line\">进入mod</span><br><span class=\"line\">参数接受的数值&#123;name=我是小菜;age=12&#125;</span><br><span class=\"line\">model传过来的值:&#123;age=40, user_name=我是小菜&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>标记在方法的参数上</li>\n</ol>\n<blockquote>\n<p>标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于view层使用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/mod2\"</span>)</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">mod2</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"user_name\"</span>)</span> String user_name,   @<span class=\"title\">ModelAttribute</span><span class=\"params\">(<span class=\"string\">\"name\"</span>)</span> String name, @<span class=\"title\">ModelAttribute</span><span class=\"params\">(<span class=\"string\">\"age\"</span>)</span> Integer age,Model model)</span>&#123; </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"进入mod2\"</span>); </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"user_name:\"</span>+user_name); </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"name：\"</span>+name);</span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"age:\"</span>+age); </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"model:\"</span>+model);   </span><br><span class=\"line\">     <span class=\"keyword\">return</span> Resp.success(<span class=\"string\">\"1\"</span>);   </span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>在浏览器中输入访问地址并且加上参数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://localhost:8081/api/test/mod2?name=我是小菜&amp;age=12</span><br></pre></td></tr></table></figure>\n<p>最终输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>进入了<span class=\"number\">1</span>：<span class=\"number\">402</span>进入了</span><br><span class=\"line\"><span class=\"number\">2</span>：我是小菜</span><br><span class=\"line\"><span class=\"number\">3</span>进入mod2</span><br><span class=\"line\"><span class=\"number\">4u</span>ser_name:我是小菜</span><br><span class=\"line\"><span class=\"number\">5</span>name：我是小菜</span><br><span class=\"line\"><span class=\"number\">6</span>age:<span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"number\">7</span>model:&#123;user_name=我是小菜, org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: <span class=\"number\">0</span> errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: <span class=\"number\">0</span> errors, age=<span class=\"number\">40</span>, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: <span class=\"number\">0</span> errors&#125;</span><br></pre></td></tr></table></figure>\n<p>从结果就能看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。</p>\n<h2 id=\"8-Cacheable\"><a href=\"#8-Cacheable\" class=\"headerlink\" title=\"8. @Cacheable\"></a>8. @Cacheable</h2><p>用于标记缓存查询，可用于方法或者类中，</p>\n<blockquote>\n<p>当标记在一个方法上时表示该方法是支持缓存的</p>\n<p>当标记在一个类上时表示该类的所有方法都是支持缓存的</p>\n</blockquote>\n<p>参数列表</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>名称</td>\n<td>@Cacheable(value={“c1”,”c2”})</td>\n</tr>\n<tr>\n<td>key</td>\n<td>key</td>\n<td>@Cacheable(value=”c1”,key=”#id”)</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>条件</td>\n<td>@Cacheable(value=”1”,condition=”#id=1”)</td>\n</tr>\n</tbody>\n</table>\n<p>比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。<br>但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable</span>(value=<span class=\"string\">\"UserCache\"</span>) <span class=\"comment\">//使用了一个缓存，名叫UserCache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Account <span class=\"title\">getUserAge</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里不用写缓存逻辑，直接按正常业务走即可</span></span><br><span class=\"line\">    <span class=\"comment\">//缓存通过切面自动切入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> age=getUser(id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-CacheEvict\"><a href=\"#9-CacheEvict\" class=\"headerlink\" title=\"9. @CacheEvict\"></a>9. @CacheEvict</h2><p>用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。</p>\n<p>@CacheEvict(value=”UserCache”)</p>\n<p><strong>参数列表</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Spring中的注解及应用\"><a href=\"#1-Spring中的注解及应用\" class=\"headerlink\" title=\"1. Spring中的注解及应用\"></a>1. Spring中的注解及应用</h1><h2 id=\"1-Controller\"><a href=\"#1-Controller\" class=\"headerlink\" title=\"1. @Controller\"></a>1. @Controller</h2><blockquote>\n<p>标识一个该类是SpringMVC Controller处理类，用来处理http请求对象</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/index\"</span>,method=Request.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">(Map&lt;String,Object&gt;map)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"2-RestController\"><a href=\"#2-RestController\" class=\"headerlink\" title=\"2. @RestController\"></a>2. @RestController</h2><blockquote>\n<p>在spring4.x之前没加入@RestController之前，@Controller要返回Json数据需要@RequestBody来配合，如果用@RestController代替@Controller，就不需要配置@RequestBody。默认返回Json。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/index\"</span>,method=Request.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">(Map&lt;String,Object&gt;map)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-Service\"><a href=\"#3-Service\" class=\"headerlink\" title=\"3. @Service\"></a>3. @Service</h2><blockquote>\n<p>用于标注业务层组件，加入该注解把这个类加入到Spring的配置中去</p>\n</blockquote>\n<h2 id=\"4-AutoWired\"><a href=\"#4-AutoWired\" class=\"headerlink\" title=\"4. AutoWired\"></a>4. AutoWired</h2><blockquote>\n<p>用来装配Bean，可以写在字段上或者方法上，默认情况下要求被依赖对象必须存在，如果允许为null，可以设置它的required属性为false，例如：@AutoWired(Required=false)</p>\n</blockquote>\n<h2 id=\"5-RequestMapping\"><a href=\"#5-RequestMapping\" class=\"headerlink\" title=\"5. @RequestMapping\"></a>5. @RequestMapping</h2><blockquote>\n<p>类定义处：提供初步的请求映射信息，相对于WEB根目录。</p>\n<p>方法处：提供进一步的细分映射信息，相对于类定义处的URL。</p>\n</blockquote>\n<h2 id=\"6-RequestParam\"><a href=\"#6-RequestParam\" class=\"headerlink\" title=\"6. @RequestParam\"></a>6. @RequestParam</h2><blockquote>\n<p>用于将请求参数区的数据映射到功能处理方法 的参数上。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">test</span><span class=\"params\">(@RequestParam Integer id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Resp.success(customerInfoService.fetch(id));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个id就是要接收 从接口传递过来的id的值的，如果传递过来的参数名和接收的不一致，可以如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">test</span><span class=\"params\">(@RequestParam(value=<span class=\"string\">\"course_id\"</span> Integer id)</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Resp.success(customerInfoService.fetch(id));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中course_id就是接口传递的参数，id就是映射course_id的参数名。</p>\n<h2 id=\"7-ModelAttribute\"><a href=\"#7-ModelAttribute\" class=\"headerlink\" title=\"7. @ModelAttribute\"></a>7. @ModelAttribute</h2><p>使用地方有三种：</p>\n<ol>\n<li>标记在方法上</li>\n</ol>\n<blockquote>\n<p>标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。</p>\n</blockquote>\n<ul>\n<li>在有返回值的方法上</li>\n</ul>\n<p>当ModelAttribute设置了value，方法返回的值会以这个value为key，以接收到的值作为value，存入到Model中，如下面的方法执行后，最总相当于model.addAttribute(“username”,name)；假如@ModelAttribute没有自定义设置value，则相当于：</p>\n<p>model.addAttribute(“name”,name);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ModelAttribute</span>(value=<span class=\"string\">\"user_name\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">before</span><span class=\"params\">(@RequestParam(required=<span class=\"keyword\">false</span>)</span>String name,Model model)</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"进入：\"</span>+name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"name\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在没有返回的方法上</li>\n</ol>\n<blockquote>\n<p>需要手动model.add方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ModelAttribute</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">(@RequestParam(required=<span class=\"keyword\">false</span>,Integer age,Model model)</span>)</span>&#123;</span><br><span class=\"line\">    model.addAttribute(<span class=\"string\">\"age\"</span>,age);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"进入：\"</span>+age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新建请求方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/mod\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">mod</span><span class=\"params\">(@RequestParam(required=<span class=\"keyword\">false</span>)</span>String name,</span></span><br><span class=\"line\"><span class=\"function\">               @<span class=\"title\">RequestParam</span><span class=\"params\">(required=<span class=\"keyword\">false</span>)</span>Integer age,Model model)</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"进入mod\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Resp.success(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在浏览器中输入访问地址并加上参数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://localhost:8081/api/test/mod?name=我是小菜&amp;age=12</span><br></pre></td></tr></table></figure>\n<p>最终输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">进入了1：40</span><br><span class=\"line\">进入了2：我是小菜</span><br><span class=\"line\">进入mod</span><br><span class=\"line\">参数接受的数值&#123;name=我是小菜;age=12&#125;</span><br><span class=\"line\">model传过来的值:&#123;age=40, user_name=我是小菜&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>标记在方法的参数上</li>\n</ol>\n<blockquote>\n<p>标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于view层使用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/mod2\"</span>)</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Resp <span class=\"title\">mod2</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"user_name\"</span>)</span> String user_name,   @<span class=\"title\">ModelAttribute</span><span class=\"params\">(<span class=\"string\">\"name\"</span>)</span> String name, @<span class=\"title\">ModelAttribute</span><span class=\"params\">(<span class=\"string\">\"age\"</span>)</span> Integer age,Model model)</span>&#123; </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"进入mod2\"</span>); </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"user_name:\"</span>+user_name); </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"name：\"</span>+name);</span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"age:\"</span>+age); </span><br><span class=\"line\">     System.out.println(<span class=\"string\">\"model:\"</span>+model);   </span><br><span class=\"line\">     <span class=\"keyword\">return</span> Resp.success(<span class=\"string\">\"1\"</span>);   </span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>在浏览器中输入访问地址并且加上参数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://localhost:8081/api/test/mod2?name=我是小菜&amp;age=12</span><br></pre></td></tr></table></figure>\n<p>最终输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>进入了<span class=\"number\">1</span>：<span class=\"number\">402</span>进入了</span><br><span class=\"line\"><span class=\"number\">2</span>：我是小菜</span><br><span class=\"line\"><span class=\"number\">3</span>进入mod2</span><br><span class=\"line\"><span class=\"number\">4u</span>ser_name:我是小菜</span><br><span class=\"line\"><span class=\"number\">5</span>name：我是小菜</span><br><span class=\"line\"><span class=\"number\">6</span>age:<span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"number\">7</span>model:&#123;user_name=我是小菜, org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: <span class=\"number\">0</span> errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: <span class=\"number\">0</span> errors, age=<span class=\"number\">40</span>, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: <span class=\"number\">0</span> errors&#125;</span><br></pre></td></tr></table></figure>\n<p>从结果就能看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。</p>\n<h2 id=\"8-Cacheable\"><a href=\"#8-Cacheable\" class=\"headerlink\" title=\"8. @Cacheable\"></a>8. @Cacheable</h2><p>用于标记缓存查询，可用于方法或者类中，</p>\n<blockquote>\n<p>当标记在一个方法上时表示该方法是支持缓存的</p>\n<p>当标记在一个类上时表示该类的所有方法都是支持缓存的</p>\n</blockquote>\n<p>参数列表</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>解释</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>名称</td>\n<td>@Cacheable(value={“c1”,”c2”})</td>\n</tr>\n<tr>\n<td>key</td>\n<td>key</td>\n<td>@Cacheable(value=”c1”,key=”#id”)</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>条件</td>\n<td>@Cacheable(value=”1”,condition=”#id=1”)</td>\n</tr>\n</tbody>\n</table>\n<p>比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。<br>但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable</span>(value=<span class=\"string\">\"UserCache\"</span>) <span class=\"comment\">//使用了一个缓存，名叫UserCache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Account <span class=\"title\">getUserAge</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里不用写缓存逻辑，直接按正常业务走即可</span></span><br><span class=\"line\">    <span class=\"comment\">//缓存通过切面自动切入</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> age=getUser(id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-CacheEvict\"><a href=\"#9-CacheEvict\" class=\"headerlink\" title=\"9. @CacheEvict\"></a>9. @CacheEvict</h2><p>用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。</p>\n<p>@CacheEvict(value=”UserCache”)</p>\n<p><strong>参数列表</strong></p>"},{"title":"springboot学习笔记","comments":0,"reward":true,"top":20,"toc":true,"abbrlink":"304afe37","date":"2018-12-25T17:07:18.000Z","_content":"\n> SpringBoot是为了简化Spring项目的快速创建、运行、调试、部署等一系列问题诞生的产物，**自动装配的特性可以让我们专注业务本身而不是外部的xml配置，我们只需要遵守规范，引入相关依赖就可以快速搭建WEB项目。**\n# 1. SpringBoot快速开始\n\n- 新建Springboot项目时，生成的目录信息：\n\n```xml\n-src\n\t-main\n\t\t-java\n\t\t\t-package\n\t\t\t\t<!--- 主函数 启动类 -->\n\t\t\t\t-SpringbootApplication\n\t\t-resources\n\t\t\t<!--存放静态资源 js/css/imges 等等-->\n\t\t\t-statics\n\t\t\t<!--存放html文件-->\n\t\t\t-templates\n\t\t\t<!--主要的配置文件。Springboot启动的时候会自动加载application.yml/application.properties-->\n\t\t\t-application.yml\n\t<!--测试文件存放目录-->\n\t-test\n```\n\n<!--more-->\n\n## 1.1 POM.xml依赖\n\n> 项目所依赖jar包\n\n## 1.2 主函数入口\n\n> 一个项目中不要出现多个main函数，否则在打包的时候spring-boot-maven-plugin将找不到函数入口（主动指定打包主函数入口除外）\n\n## 1.3 配置文件\n\n```properties\n# 修改默认端口8080 为8090\nserver.port=8090\n# 未定义上下文路径时，地址是http://localhost:8080 定义了之后http://localhost:8090 在Tomcat能配置的 都可以配置\nserver.servlet.context-path=/demo\n```\n\n## 1.4 自定义Banner\n\n```java\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.1.RELEASE)\n```\n\n> SpringBoot启动时会有如上内容，自定义方法：\n>\n> 字需要在resources文件下指定命名的文件即可，例如：\n>\n> banner.txt、banner.jpg、banner.gif、banner.jpeg等等\n\n# 2. SpringBoot配置详解\n\n## 2.1 自定义属性配置\n\n- application.properties\n\n  1. 配置文件的书写形式：key-value形式 如：\n\n     ~~~ properties\n     my1.age=20\n     my1.name=teddy\n     ~~~\n\n  2. 接下来定义properties.java配置文件，映射application.properties中的内容，之后就可以通过操作对象的方式获得配置文件中的内容。\n\n     ~~~ java\n     @Component //注册组件\n     @ConfigurationProperties(prefix=\"my1\")\n     public class Properties{\n         private int age;\n         private String name;\n         // 省略 get set\n         @override\n         public String toString(){\n             return \"properties{\"+\n                 \"age=\"+age+\n                 \",name='\"+name+'\\''+\n                 '}';\n         }\n     }\n     ~~~\n\n  3. 接下来定义controller用来引入properties.java配置文件,进行测试。Spring4.x以后推荐使用构造函数形式注入属性。\n\n      ```java\n        @RequestMapping(\"/properties\")\n        @RestController\n        public class PropertiesController{\n         private static final Logger log=LoggerFactory.getlogger(PropertiesController.class);\n         private final Properties properties；\n             @AutoWired\n             public PropertiesController(Properties properties){\n             this.properties=properties;\n         }\n         public Properties properties(){\n             log.info(\"===========================\");\n             log.info(properties.toString());\n             log.info(\"===========================\");\n             return properties;\n         }\n        }\n      ```\n\n## 2.2 自定义文件配置\n\n1. 定义一个名为my2.properties的资源文件，**自定义配置文件的命名不强制application开头**\n\n```properties\nmy2.age=22\nmy2.name=Jhon\n```\n\n2. 定义Properties1.java文件，用来映射my2.properties文件中的内容。\n\n   ```java\n   @Component\n   @PropertySource(\"classpath:my2.properties\")\n   @ConfigurationProperties(prefix=\"my2\")\n   public class Properties1{\n       private int age;\n       private String name;\n       // 省略 get set\n    @Override\n       public String toString() {\n           return \"MyProperties2{\" +\n                   \"age=\" + age +\n                   \", name='\" + name + '\\'' +\n                   \", email='\" + email + '\\'' +\n                   '}';\n   }\n   ```\n\n## 2.3 多环境话配置\n\n> 在真实的应用中，常常会有多个环境（如：开发、测试、生产等），不同的数据库连接都不一样，这个时候就需要用到spring.profile.active的强大功能了，它的格式为application-{profile}.properties,这里的**application**为前缀不能更改，{profile}是我们自定义的。如下：\n\n- application-dev.properties\n\n  ```properties\n  server.servlet.context-path=/dev\n  ```\n\n- application-test.properties\n\n  ```properties\n  server.servlet.context-path=/test\n  ```\n\n- application-prod.properties\n\n  ``` properties\n  server.servlet.context-path=/prod\n  ```\n\n> 之后在application.properties配置文件中写入spring.profiles.active=xxx，这个时候再次访问：http://localhost:8090/properties/1就没用了，因为我们设置了context-path=xxx，所以新路径就是：http://localhost:8090/xxx/properties/1\n\n## 2.4 外部命令测试\n\n- 如何测试\n\n  1. 进入到项目目录\n\n  2. 打开cmd程序，输入\n\n     ```\n     mvn package\n     ```\n\n  3. 打包完毕后进入当前项目的target目录，可以发现命名为xxx.jar的文件。\n\n  4. 接着在cmd命令行输入\n\n     ```bash\n     java -jar xxx.jar --spring.profiles.active=test --my1.age=23\n     ```\n\n  5. 最后输入url测试:http://localhost:8090/test/properties/1 返回值。\n\n# 3. Springboot日志配置\n\n\n\n","source":"_posts/springboot学习笔记.md","raw":"---\ntitle: springboot学习笔记\ncomments: false\nreward: true\ntags: springboot\ncategories: 技术\ntop: 20\ntoc: true\nabbrlink: 304afe37\ndate: 2018-12-26 01:07:18\n---\n\n> SpringBoot是为了简化Spring项目的快速创建、运行、调试、部署等一系列问题诞生的产物，**自动装配的特性可以让我们专注业务本身而不是外部的xml配置，我们只需要遵守规范，引入相关依赖就可以快速搭建WEB项目。**\n# 1. SpringBoot快速开始\n\n- 新建Springboot项目时，生成的目录信息：\n\n```xml\n-src\n\t-main\n\t\t-java\n\t\t\t-package\n\t\t\t\t<!--- 主函数 启动类 -->\n\t\t\t\t-SpringbootApplication\n\t\t-resources\n\t\t\t<!--存放静态资源 js/css/imges 等等-->\n\t\t\t-statics\n\t\t\t<!--存放html文件-->\n\t\t\t-templates\n\t\t\t<!--主要的配置文件。Springboot启动的时候会自动加载application.yml/application.properties-->\n\t\t\t-application.yml\n\t<!--测试文件存放目录-->\n\t-test\n```\n\n<!--more-->\n\n## 1.1 POM.xml依赖\n\n> 项目所依赖jar包\n\n## 1.2 主函数入口\n\n> 一个项目中不要出现多个main函数，否则在打包的时候spring-boot-maven-plugin将找不到函数入口（主动指定打包主函数入口除外）\n\n## 1.3 配置文件\n\n```properties\n# 修改默认端口8080 为8090\nserver.port=8090\n# 未定义上下文路径时，地址是http://localhost:8080 定义了之后http://localhost:8090 在Tomcat能配置的 都可以配置\nserver.servlet.context-path=/demo\n```\n\n## 1.4 自定义Banner\n\n```java\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.1.RELEASE)\n```\n\n> SpringBoot启动时会有如上内容，自定义方法：\n>\n> 字需要在resources文件下指定命名的文件即可，例如：\n>\n> banner.txt、banner.jpg、banner.gif、banner.jpeg等等\n\n# 2. SpringBoot配置详解\n\n## 2.1 自定义属性配置\n\n- application.properties\n\n  1. 配置文件的书写形式：key-value形式 如：\n\n     ~~~ properties\n     my1.age=20\n     my1.name=teddy\n     ~~~\n\n  2. 接下来定义properties.java配置文件，映射application.properties中的内容，之后就可以通过操作对象的方式获得配置文件中的内容。\n\n     ~~~ java\n     @Component //注册组件\n     @ConfigurationProperties(prefix=\"my1\")\n     public class Properties{\n         private int age;\n         private String name;\n         // 省略 get set\n         @override\n         public String toString(){\n             return \"properties{\"+\n                 \"age=\"+age+\n                 \",name='\"+name+'\\''+\n                 '}';\n         }\n     }\n     ~~~\n\n  3. 接下来定义controller用来引入properties.java配置文件,进行测试。Spring4.x以后推荐使用构造函数形式注入属性。\n\n      ```java\n        @RequestMapping(\"/properties\")\n        @RestController\n        public class PropertiesController{\n         private static final Logger log=LoggerFactory.getlogger(PropertiesController.class);\n         private final Properties properties；\n             @AutoWired\n             public PropertiesController(Properties properties){\n             this.properties=properties;\n         }\n         public Properties properties(){\n             log.info(\"===========================\");\n             log.info(properties.toString());\n             log.info(\"===========================\");\n             return properties;\n         }\n        }\n      ```\n\n## 2.2 自定义文件配置\n\n1. 定义一个名为my2.properties的资源文件，**自定义配置文件的命名不强制application开头**\n\n```properties\nmy2.age=22\nmy2.name=Jhon\n```\n\n2. 定义Properties1.java文件，用来映射my2.properties文件中的内容。\n\n   ```java\n   @Component\n   @PropertySource(\"classpath:my2.properties\")\n   @ConfigurationProperties(prefix=\"my2\")\n   public class Properties1{\n       private int age;\n       private String name;\n       // 省略 get set\n    @Override\n       public String toString() {\n           return \"MyProperties2{\" +\n                   \"age=\" + age +\n                   \", name='\" + name + '\\'' +\n                   \", email='\" + email + '\\'' +\n                   '}';\n   }\n   ```\n\n## 2.3 多环境话配置\n\n> 在真实的应用中，常常会有多个环境（如：开发、测试、生产等），不同的数据库连接都不一样，这个时候就需要用到spring.profile.active的强大功能了，它的格式为application-{profile}.properties,这里的**application**为前缀不能更改，{profile}是我们自定义的。如下：\n\n- application-dev.properties\n\n  ```properties\n  server.servlet.context-path=/dev\n  ```\n\n- application-test.properties\n\n  ```properties\n  server.servlet.context-path=/test\n  ```\n\n- application-prod.properties\n\n  ``` properties\n  server.servlet.context-path=/prod\n  ```\n\n> 之后在application.properties配置文件中写入spring.profiles.active=xxx，这个时候再次访问：http://localhost:8090/properties/1就没用了，因为我们设置了context-path=xxx，所以新路径就是：http://localhost:8090/xxx/properties/1\n\n## 2.4 外部命令测试\n\n- 如何测试\n\n  1. 进入到项目目录\n\n  2. 打开cmd程序，输入\n\n     ```\n     mvn package\n     ```\n\n  3. 打包完毕后进入当前项目的target目录，可以发现命名为xxx.jar的文件。\n\n  4. 接着在cmd命令行输入\n\n     ```bash\n     java -jar xxx.jar --spring.profiles.active=test --my1.age=23\n     ```\n\n  5. 最后输入url测试:http://localhost:8090/test/properties/1 返回值。\n\n# 3. Springboot日志配置\n\n\n\n","slug":"springboot学习笔记","published":1,"updated":"2018-12-28T09:16:00.726Z","layout":"post","photos":[],"link":"","_id":"cjq7zalce0006oos2x27h3wcg","content":"<blockquote>\n<p>SpringBoot是为了简化Spring项目的快速创建、运行、调试、部署等一系列问题诞生的产物，<strong>自动装配的特性可以让我们专注业务本身而不是外部的xml配置，我们只需要遵守规范，引入相关依赖就可以快速搭建WEB项目。</strong></p>\n</blockquote>\n<h1 id=\"1-SpringBoot快速开始\"><a href=\"#1-SpringBoot快速开始\" class=\"headerlink\" title=\"1. SpringBoot快速开始\"></a>1. SpringBoot快速开始</h1><ul>\n<li>新建Springboot项目时，生成的目录信息：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">-src</span><br><span class=\"line\">\t-main</span><br><span class=\"line\">\t\t-java</span><br><span class=\"line\">\t\t\t-package</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">&lt;!--- 主函数 启动类 --&gt;</span></span><br><span class=\"line\">\t\t\t\t-SpringbootApplication</span><br><span class=\"line\">\t\t-resources</span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--存放静态资源 js/css/imges 等等--&gt;</span></span><br><span class=\"line\">\t\t\t-statics</span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--存放html文件--&gt;</span></span><br><span class=\"line\">\t\t\t-templates</span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--主要的配置文件。Springboot启动的时候会自动加载application.yml/application.properties--&gt;</span></span><br><span class=\"line\">\t\t\t-application.yml</span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--测试文件存放目录--&gt;</span></span><br><span class=\"line\">\t-test</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"1-1-POM-xml依赖\"><a href=\"#1-1-POM-xml依赖\" class=\"headerlink\" title=\"1.1 POM.xml依赖\"></a>1.1 POM.xml依赖</h2><blockquote>\n<p>项目所依赖jar包</p>\n</blockquote>\n<h2 id=\"1-2-主函数入口\"><a href=\"#1-2-主函数入口\" class=\"headerlink\" title=\"1.2 主函数入口\"></a>1.2 主函数入口</h2><blockquote>\n<p>一个项目中不要出现多个main函数，否则在打包的时候spring-boot-maven-plugin将找不到函数入口（主动指定打包主函数入口除外）</p>\n</blockquote>\n<h2 id=\"1-3-配置文件\"><a href=\"#1-3-配置文件\" class=\"headerlink\" title=\"1.3 配置文件\"></a>1.3 配置文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 修改默认端口8080 为8090</span><br><span class=\"line\">server.port=8090</span><br><span class=\"line\"># 未定义上下文路径时，地址是http://localhost:8080 定义了之后http://localhost:8090 在Tomcat能配置的 都可以配置</span><br><span class=\"line\">server.servlet.context-path=/demo</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-4-自定义Banner\"><a href=\"#1-4-自定义Banner\" class=\"headerlink\" title=\"1.4 自定义Banner\"></a>1.4 自定义Banner</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  .   ____          _            __ _ _</span><br><span class=\"line\"> /\\\\ / ___<span class=\"string\">'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</span></span><br><span class=\"line\"><span class=\"string\">( ( )\\___ | '</span>_ | <span class=\"string\">'_| | '</span>_ \\/ _` | \\ \\ \\ \\</span><br><span class=\"line\"> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class=\"line\">  <span class=\"string\">'  |____| .__|_| |_|_| |_\\__, | / / / /</span></span><br><span class=\"line\"><span class=\"string\"> =========|_|==============|___/=/_/_/_/</span></span><br><span class=\"line\"><span class=\"string\"> :: Spring Boot ::        (v2.0.1.RELEASE)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>SpringBoot启动时会有如上内容，自定义方法：</p>\n<p>字需要在resources文件下指定命名的文件即可，例如：</p>\n<p>banner.txt、banner.jpg、banner.gif、banner.jpeg等等</p>\n</blockquote>\n<h1 id=\"2-SpringBoot配置详解\"><a href=\"#2-SpringBoot配置详解\" class=\"headerlink\" title=\"2. SpringBoot配置详解\"></a>2. SpringBoot配置详解</h1><h2 id=\"2-1-自定义属性配置\"><a href=\"#2-1-自定义属性配置\" class=\"headerlink\" title=\"2.1 自定义属性配置\"></a>2.1 自定义属性配置</h2><ul>\n<li><p>application.properties</p>\n<ol>\n<li><p>配置文件的书写形式：key-value形式 如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">my1.age=20</span><br><span class=\"line\">my1.name=teddy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来定义properties.java配置文件，映射application.properties中的内容，之后就可以通过操作对象的方式获得配置文件中的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">//注册组件</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix=<span class=\"string\">\"my1\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Properties</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// 省略 get set</span></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"properties&#123;\"</span>+</span><br><span class=\"line\">            <span class=\"string\">\"age=\"</span>+age+</span><br><span class=\"line\">            <span class=\"string\">\",name='\"</span>+name+<span class=\"string\">'\\''</span>+</span><br><span class=\"line\">            <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来定义controller用来引入properties.java配置文件,进行测试。Spring4.x以后推荐使用构造函数形式注入属性。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/properties\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertiesController</span></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log=LoggerFactory.getlogger(PropertiesController.class);</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Properties properties；</span><br><span class=\"line\">     <span class=\"meta\">@AutoWired</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PropertiesController</span><span class=\"params\">(Properties properties)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.properties=properties;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Properties <span class=\"title\">properties</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">     log.info(<span class=\"string\">\"===========================\"</span>);</span><br><span class=\"line\">     log.info(properties.toString());</span><br><span class=\"line\">     log.info(<span class=\"string\">\"===========================\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> properties;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-自定义文件配置\"><a href=\"#2-2-自定义文件配置\" class=\"headerlink\" title=\"2.2 自定义文件配置\"></a>2.2 自定义文件配置</h2><ol>\n<li>定义一个名为my2.properties的资源文件，<strong>自定义配置文件的命名不强制application开头</strong></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">my2.age=22</span><br><span class=\"line\">my2.name=Jhon</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>定义Properties1.java文件，用来映射my2.properties文件中的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource</span>(<span class=\"string\">\"classpath:my2.properties\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix=<span class=\"string\">\"my2\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Properties1</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// 省略 get set</span></span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"MyProperties2&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"age=\"</span> + age +</span><br><span class=\"line\">                <span class=\"string\">\", name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"2-3-多环境话配置\"><a href=\"#2-3-多环境话配置\" class=\"headerlink\" title=\"2.3 多环境话配置\"></a>2.3 多环境话配置</h2><blockquote>\n<p>在真实的应用中，常常会有多个环境（如：开发、测试、生产等），不同的数据库连接都不一样，这个时候就需要用到spring.profile.active的强大功能了，它的格式为application-{profile}.properties,这里的<strong>application</strong>为前缀不能更改，{profile}是我们自定义的。如下：</p>\n</blockquote>\n<ul>\n<li><p>application-dev.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.servlet.context-path=/dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>application-test.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.servlet.context-path=/test</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>application-prod.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.servlet.context-path=/prod</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>之后在application.properties配置文件中写入spring.profiles.active=xxx，这个时候再次访问：<a href=\"http://localhost:8090/properties/1就没用了，因为我们设置了context-path=xxx，所以新路径就是：http://localhost:8090/xxx/properties/1\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/properties/1就没用了，因为我们设置了context-path=xxx，所以新路径就是：http://localhost:8090/xxx/properties/1</a></p>\n</blockquote>\n<h2 id=\"2-4-外部命令测试\"><a href=\"#2-4-外部命令测试\" class=\"headerlink\" title=\"2.4 外部命令测试\"></a>2.4 外部命令测试</h2><ul>\n<li><p>如何测试</p>\n<ol>\n<li><p>进入到项目目录</p>\n</li>\n<li><p>打开cmd程序，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn package</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打包完毕后进入当前项目的target目录，可以发现命名为xxx.jar的文件。</p>\n</li>\n<li><p>接着在cmd命令行输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar xxx.jar --spring.profiles.active=<span class=\"built_in\">test</span> --my1.age=23</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后输入url测试:<a href=\"http://localhost:8090/test/properties/1\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/test/properties/1</a> 返回值。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"3-Springboot日志配置\"><a href=\"#3-Springboot日志配置\" class=\"headerlink\" title=\"3. Springboot日志配置\"></a>3. Springboot日志配置</h1>","site":{"data":{}},"excerpt":"<blockquote>\n<p>SpringBoot是为了简化Spring项目的快速创建、运行、调试、部署等一系列问题诞生的产物，<strong>自动装配的特性可以让我们专注业务本身而不是外部的xml配置，我们只需要遵守规范，引入相关依赖就可以快速搭建WEB项目。</strong></p>\n</blockquote>\n<h1 id=\"1-SpringBoot快速开始\"><a href=\"#1-SpringBoot快速开始\" class=\"headerlink\" title=\"1. SpringBoot快速开始\"></a>1. SpringBoot快速开始</h1><ul>\n<li>新建Springboot项目时，生成的目录信息：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">-src</span><br><span class=\"line\">\t-main</span><br><span class=\"line\">\t\t-java</span><br><span class=\"line\">\t\t\t-package</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">&lt;!--- 主函数 启动类 --&gt;</span></span><br><span class=\"line\">\t\t\t\t-SpringbootApplication</span><br><span class=\"line\">\t\t-resources</span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--存放静态资源 js/css/imges 等等--&gt;</span></span><br><span class=\"line\">\t\t\t-statics</span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--存放html文件--&gt;</span></span><br><span class=\"line\">\t\t\t-templates</span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--主要的配置文件。Springboot启动的时候会自动加载application.yml/application.properties--&gt;</span></span><br><span class=\"line\">\t\t\t-application.yml</span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--测试文件存放目录--&gt;</span></span><br><span class=\"line\">\t-test</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"1-1-POM-xml依赖\"><a href=\"#1-1-POM-xml依赖\" class=\"headerlink\" title=\"1.1 POM.xml依赖\"></a>1.1 POM.xml依赖</h2><blockquote>\n<p>项目所依赖jar包</p>\n</blockquote>\n<h2 id=\"1-2-主函数入口\"><a href=\"#1-2-主函数入口\" class=\"headerlink\" title=\"1.2 主函数入口\"></a>1.2 主函数入口</h2><blockquote>\n<p>一个项目中不要出现多个main函数，否则在打包的时候spring-boot-maven-plugin将找不到函数入口（主动指定打包主函数入口除外）</p>\n</blockquote>\n<h2 id=\"1-3-配置文件\"><a href=\"#1-3-配置文件\" class=\"headerlink\" title=\"1.3 配置文件\"></a>1.3 配置文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 修改默认端口8080 为8090</span><br><span class=\"line\">server.port=8090</span><br><span class=\"line\"># 未定义上下文路径时，地址是http://localhost:8080 定义了之后http://localhost:8090 在Tomcat能配置的 都可以配置</span><br><span class=\"line\">server.servlet.context-path=/demo</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-4-自定义Banner\"><a href=\"#1-4-自定义Banner\" class=\"headerlink\" title=\"1.4 自定义Banner\"></a>1.4 自定义Banner</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  .   ____          _            __ _ _</span><br><span class=\"line\"> /\\\\ / ___<span class=\"string\">'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\</span></span><br><span class=\"line\"><span class=\"string\">( ( )\\___ | '</span>_ | <span class=\"string\">'_| | '</span>_ \\/ _` | \\ \\ \\ \\</span><br><span class=\"line\"> \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class=\"line\">  <span class=\"string\">'  |____| .__|_| |_|_| |_\\__, | / / / /</span></span><br><span class=\"line\"><span class=\"string\"> =========|_|==============|___/=/_/_/_/</span></span><br><span class=\"line\"><span class=\"string\"> :: Spring Boot ::        (v2.0.1.RELEASE)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>SpringBoot启动时会有如上内容，自定义方法：</p>\n<p>字需要在resources文件下指定命名的文件即可，例如：</p>\n<p>banner.txt、banner.jpg、banner.gif、banner.jpeg等等</p>\n</blockquote>\n<h1 id=\"2-SpringBoot配置详解\"><a href=\"#2-SpringBoot配置详解\" class=\"headerlink\" title=\"2. SpringBoot配置详解\"></a>2. SpringBoot配置详解</h1><h2 id=\"2-1-自定义属性配置\"><a href=\"#2-1-自定义属性配置\" class=\"headerlink\" title=\"2.1 自定义属性配置\"></a>2.1 自定义属性配置</h2><ul>\n<li><p>application.properties</p>\n<ol>\n<li><p>配置文件的书写形式：key-value形式 如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">my1.age=20</span><br><span class=\"line\">my1.name=teddy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来定义properties.java配置文件，映射application.properties中的内容，之后就可以通过操作对象的方式获得配置文件中的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">//注册组件</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix=<span class=\"string\">\"my1\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Properties</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// 省略 get set</span></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"properties&#123;\"</span>+</span><br><span class=\"line\">            <span class=\"string\">\"age=\"</span>+age+</span><br><span class=\"line\">            <span class=\"string\">\",name='\"</span>+name+<span class=\"string\">'\\''</span>+</span><br><span class=\"line\">            <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来定义controller用来引入properties.java配置文件,进行测试。Spring4.x以后推荐使用构造函数形式注入属性。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/properties\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertiesController</span></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log=LoggerFactory.getlogger(PropertiesController.class);</span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Properties properties；</span><br><span class=\"line\">     <span class=\"meta\">@AutoWired</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PropertiesController</span><span class=\"params\">(Properties properties)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.properties=properties;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Properties <span class=\"title\">properties</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">     log.info(<span class=\"string\">\"===========================\"</span>);</span><br><span class=\"line\">     log.info(properties.toString());</span><br><span class=\"line\">     log.info(<span class=\"string\">\"===========================\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> properties;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-2-自定义文件配置\"><a href=\"#2-2-自定义文件配置\" class=\"headerlink\" title=\"2.2 自定义文件配置\"></a>2.2 自定义文件配置</h2><ol>\n<li>定义一个名为my2.properties的资源文件，<strong>自定义配置文件的命名不强制application开头</strong></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">my2.age=22</span><br><span class=\"line\">my2.name=Jhon</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>定义Properties1.java文件，用来映射my2.properties文件中的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource</span>(<span class=\"string\">\"classpath:my2.properties\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix=<span class=\"string\">\"my2\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Properties1</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">// 省略 get set</span></span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"MyProperties2&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"age=\"</span> + age +</span><br><span class=\"line\">                <span class=\"string\">\", name='\"</span> + name + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", email='\"</span> + email + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"2-3-多环境话配置\"><a href=\"#2-3-多环境话配置\" class=\"headerlink\" title=\"2.3 多环境话配置\"></a>2.3 多环境话配置</h2><blockquote>\n<p>在真实的应用中，常常会有多个环境（如：开发、测试、生产等），不同的数据库连接都不一样，这个时候就需要用到spring.profile.active的强大功能了，它的格式为application-{profile}.properties,这里的<strong>application</strong>为前缀不能更改，{profile}是我们自定义的。如下：</p>\n</blockquote>\n<ul>\n<li><p>application-dev.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.servlet.context-path=/dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>application-test.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.servlet.context-path=/test</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>application-prod.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.servlet.context-path=/prod</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>之后在application.properties配置文件中写入spring.profiles.active=xxx，这个时候再次访问：<a href=\"http://localhost:8090/properties/1就没用了，因为我们设置了context-path=xxx，所以新路径就是：http://localhost:8090/xxx/properties/1\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/properties/1就没用了，因为我们设置了context-path=xxx，所以新路径就是：http://localhost:8090/xxx/properties/1</a></p>\n</blockquote>\n<h2 id=\"2-4-外部命令测试\"><a href=\"#2-4-外部命令测试\" class=\"headerlink\" title=\"2.4 外部命令测试\"></a>2.4 外部命令测试</h2><ul>\n<li><p>如何测试</p>\n<ol>\n<li><p>进入到项目目录</p>\n</li>\n<li><p>打开cmd程序，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn package</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打包完毕后进入当前项目的target目录，可以发现命名为xxx.jar的文件。</p>\n</li>\n<li><p>接着在cmd命令行输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar xxx.jar --spring.profiles.active=<span class=\"built_in\">test</span> --my1.age=23</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后输入url测试:<a href=\"http://localhost:8090/test/properties/1\" target=\"_blank\" rel=\"noopener\">http://localhost:8090/test/properties/1</a> 返回值。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"3-Springboot日志配置\"><a href=\"#3-Springboot日志配置\" class=\"headerlink\" title=\"3. Springboot日志配置\"></a>3. Springboot日志配置</h1>"},{"title":"死磕java基础","comments":0,"reward":true,"toc":true,"copyright":true,"abbrlink":"a8bf2e04","date":"2018-12-26T16:05:38.000Z","top":null,"_content":"\n# 1. 关键字final和static总结\n## 1.1 final\n>  根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。\n>\n>  1. final类不能被继承，没有子类，final类中的方法默认是final的。\n>  2. final方法不能被子类的方法覆盖，但可以被继承。\n>  3. final成员变量表示常量，只能被赋值一次，赋值后值不再改变。\n>  4. final不能用于修饰构造方法。\n>      **注意：**父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的.      \n\n<!--more-->\n\n1. final类\n\n> final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。\n\n2. final方法\n\n>  如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。\n>  使用final方法的原因有二：\n>\n>  1. 把方法锁定，防止任何继承类修改它的意义和实现。\n>  2. 高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。\n---\n\n```java\npublic class Test1 { \npublic static void main(String[] args) { \n    // TODO 自动生成方法存根 \n} \npublic void f1() { \n    System.out.println(\"f1\"); \n} \n//无法被子类覆盖的方法 \npublic final void f2() { \n    System.out.println(\"f2\"); \n} \npublic void f3() { \n    System.out.println(\"f3\"); \n} \nprivate void f4() { \n    System.out.println(\"f4\"); \n} \n} \npublic class Test2 extends Test1 { \n    \npublic void f1(){     \n    System.out.println(\"Test1父类方法f1被覆盖!\"); \n} \npublic static void main(String[] args) { \n    Test2 t=new Test2(); \n    t.f1();    \n    t.f2(); //调用从父类继承过来的final方法 \n    t.f3(); //调用从父类继承过来的方法 \n    //t.f4(); //调用失败，无法从父类继承获得 \n} \n}\n```\n\n3. final变量（常量）\n\n> 用final修饰的成员变量表示常量，值一旦给定就无法改变！\n> ​        final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。\n> ​        从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。\n> ​        另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器  都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。\n\n```java\npublic class Test3 { \n        private final String S = \"final实例变量S\"; \n        private final int A = 100; \n        public final int B = 90; \n\n        public static final int C = 80; \n        private static final int D = 70; \n\n        public final int E; //final空白,必须在初始化对象的时候赋初值 \n\n        public Test3(int x) { \n                E = x; \n        } \n\n        /** \n         * @param args \n         */ \n        public static void main(String[] args) { \n                Test3 t = new Test3(2); \n                //t.A=101;    //出错,final变量的值一旦给定就无法改变 \n                //t.B=91; //出错,final变量的值一旦给定就无法改变 \n                //t.C=81; //出错,final变量的值一旦给定就无法改变 \n                //t.D=71; //出错,final变量的值一旦给定就无法改变 \n\n                System.out.println(t.A); \n                System.out.println(t.B); \n                System.out.println(t.C); //不推荐用对象方式访问静态字段 \n                System.out.println(t.D); //不推荐用对象方式访问静态字段 \n                System.out.println(Test3.C); \n                System.out.println(Test3.D); \n                //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. \n                System.out.println(t.E); \n\n                Test3 t1 = new Test3(3); \n                System.out.println(t1.E); //final空白变量E依据对象的不同而不同 \n        } \n\n        private void test() { \n                System.out.println(new Test3(1).A); \n                System.out.println(Test3.C); \n                System.out.println(Test3.D); \n        } \n\n        public void test2() { \n                final int a;     //final空白,在需要的时候才赋值 \n                final int b = 4;    //局部常量--final用于局部变量的情形 \n                final int c;    //final空白,一直没有给赋值.    \n                a = 3; \n                //a=4;    出错,已经给赋过值了. \n                //b=2; 出错,已经给赋过值了. \n        } \n}\n```\n\n4. final参数\n\n> 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。\n\n```java\npublic class Test4 { \n        public static void main(String[] args) { \n                new Test4().f1(2); \n        } \n\n        public void f1(final int i) { \n                //i++;    //i是final类型的,值不允许改变的. \n                System.out.print(i); \n        } \n}\n```\n\n## 1.2 static\n\n> static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。\n>\n>  **被static修饰的成员变量和成员方法独立于该类的任何对象。**也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。\n>\n> **用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。**\n>\n> **static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。**\n>\n> 实际上你需要搞明白，**private是访问权限限定，static表示不要实例化就可以使用，**这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。\n>\n> static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：\n> 类名.静态方法名(参数列表...) \n> 类名.静态变量名\n>\n>         用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块。\n\n1. static变量\n\n>   按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：\n>   ​      对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。\n>   ​      对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。\n\n2. 静态方法\n\n> 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！\n> ​        因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。\n\n3. static代码块\n\n> static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。\n\n```java\npublic class Test5 { \n        private static int a; \n        private int b; \n\n        static { \n                Test5.a = 3; \n                System.out.println(a); \n                Test5 t = new Test5(); \n                t.f(); \n                t.b = 1000; \n                System.out.println(t.b); \n        } \n\n        static { \n                Test5.a = 4; \n                System.out.println(a); \n        } \n\n        public static void main(String[] args) { \n                // TODO 自动生成方法存根 \n        } \n\n        static { \n                Test5.a = 5; \n                System.out.println(a); \n        } \n\n        public void f() { \n                System.out.println(\"hhahhahah\"); \n        } \n}\n```\n\n```java\n运行结果：\n3\nhhahhahah\n1000\n4\n5\n```\n\n>   利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。\n\n4. static和final一块用表示什么\n\n> static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！\n>\n> 1. 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。\n> 2. 对于方法，表示不可覆盖，并且可以通过类名直接访问。 \n>\n>       \n>\n>    **特别要注意一个问题：**\n>\n>         对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。\n\n```java\npublic class TestStaticFinal { \n        private static final String strStaticFinalVar = \"aaa\"; \n        private static String strStaticVar = null; \n        private final String strFinalVar = null; \n        private static final int intStaticFinalVar = 0; \n        private static final Integer integerStaticFinalVar = new Integer(8); \n        private static final ArrayList<String> alStaticFinalVar = new ArrayList<String>(); \n\n        private void test() { \n                System.out.println(\"-------------值处理前----------\\r\\n\"); \n                System.out.println(\"strStaticFinalVar=\" + strStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"strStaticVar=\" + strStaticVar + \"\\r\\n\"); \n                System.out.println(\"strFinalVar=\" + strFinalVar + \"\\r\\n\"); \n                System.out.println(\"intStaticFinalVar=\" + intStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"integerStaticFinalVar=\" + integerStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"alStaticFinalVar=\" + alStaticFinalVar + \"\\r\\n\"); \n\n\n                //strStaticFinalVar=\"哈哈哈哈\";        //错误，final表示终态,不可以改变变量本身. \n                strStaticVar = \"哈哈哈哈\";                //正确，static表示类变量,值可以改变. \n                //strFinalVar=\"呵呵呵呵\";                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                //intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                //integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                alStaticFinalVar.add(\"aaa\");        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 \n                alStaticFinalVar.add(\"bbb\");        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 \n\n                System.out.println(\"-------------值处理后----------\\r\\n\"); \n                System.out.println(\"strStaticFinalVar=\" + strStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"strStaticVar=\" + strStaticVar + \"\\r\\n\"); \n                System.out.println(\"strFinalVar=\" + strFinalVar + \"\\r\\n\"); \n                System.out.println(\"intStaticFinalVar=\" + intStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"integerStaticFinalVar=\" + integerStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"alStaticFinalVar=\" + alStaticFinalVar + \"\\r\\n\"); \n        } \n\n        public static void main(String args[]) { \n                new TestStaticFinal().test(); \n        } \n}\n```\n\n```java\n运行结果如下：\n-------------值处理前----------\nstrStaticFinalVar=aaa\nstrStaticVar=null\nstrFinalVar=null\nintStaticFinalVar=0\nintegerStaticFinalVar=8\nalStaticFinalVar=[]\n-------------值处理后----------\nstrStaticFinalVar=aaa\nstrStaticVar=哈哈哈哈\nstrFinalVar=null\nintStaticFinalVar=0\nintegerStaticFinalVar=8\nalStaticFinalVar=[aaa, bbb]\n\nProcess finished with exit code 0\n```\n\n# 2. transient关键字\n\n# 3. 对象序列化Serializable和Externalizable\n\n# 4. 持有对象","source":"_posts/死磕java基础.md","raw":"---\ntitle: 死磕java基础\ncomments: false\nreward: true\ntoc: true\ncopyright: true\ntags: java基础\ncategories: 技术\nabbrlink: a8bf2e04\ndate: 2018-12-27 00:05:38\ntop:\n---\n\n# 1. 关键字final和static总结\n## 1.1 final\n>  根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。\n>\n>  1. final类不能被继承，没有子类，final类中的方法默认是final的。\n>  2. final方法不能被子类的方法覆盖，但可以被继承。\n>  3. final成员变量表示常量，只能被赋值一次，赋值后值不再改变。\n>  4. final不能用于修饰构造方法。\n>      **注意：**父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的.      \n\n<!--more-->\n\n1. final类\n\n> final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。\n\n2. final方法\n\n>  如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。\n>  使用final方法的原因有二：\n>\n>  1. 把方法锁定，防止任何继承类修改它的意义和实现。\n>  2. 高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。\n---\n\n```java\npublic class Test1 { \npublic static void main(String[] args) { \n    // TODO 自动生成方法存根 \n} \npublic void f1() { \n    System.out.println(\"f1\"); \n} \n//无法被子类覆盖的方法 \npublic final void f2() { \n    System.out.println(\"f2\"); \n} \npublic void f3() { \n    System.out.println(\"f3\"); \n} \nprivate void f4() { \n    System.out.println(\"f4\"); \n} \n} \npublic class Test2 extends Test1 { \n    \npublic void f1(){     \n    System.out.println(\"Test1父类方法f1被覆盖!\"); \n} \npublic static void main(String[] args) { \n    Test2 t=new Test2(); \n    t.f1();    \n    t.f2(); //调用从父类继承过来的final方法 \n    t.f3(); //调用从父类继承过来的方法 \n    //t.f4(); //调用失败，无法从父类继承获得 \n} \n}\n```\n\n3. final变量（常量）\n\n> 用final修饰的成员变量表示常量，值一旦给定就无法改变！\n> ​        final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。\n> ​        从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。\n> ​        另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器  都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。\n\n```java\npublic class Test3 { \n        private final String S = \"final实例变量S\"; \n        private final int A = 100; \n        public final int B = 90; \n\n        public static final int C = 80; \n        private static final int D = 70; \n\n        public final int E; //final空白,必须在初始化对象的时候赋初值 \n\n        public Test3(int x) { \n                E = x; \n        } \n\n        /** \n         * @param args \n         */ \n        public static void main(String[] args) { \n                Test3 t = new Test3(2); \n                //t.A=101;    //出错,final变量的值一旦给定就无法改变 \n                //t.B=91; //出错,final变量的值一旦给定就无法改变 \n                //t.C=81; //出错,final变量的值一旦给定就无法改变 \n                //t.D=71; //出错,final变量的值一旦给定就无法改变 \n\n                System.out.println(t.A); \n                System.out.println(t.B); \n                System.out.println(t.C); //不推荐用对象方式访问静态字段 \n                System.out.println(t.D); //不推荐用对象方式访问静态字段 \n                System.out.println(Test3.C); \n                System.out.println(Test3.D); \n                //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. \n                System.out.println(t.E); \n\n                Test3 t1 = new Test3(3); \n                System.out.println(t1.E); //final空白变量E依据对象的不同而不同 \n        } \n\n        private void test() { \n                System.out.println(new Test3(1).A); \n                System.out.println(Test3.C); \n                System.out.println(Test3.D); \n        } \n\n        public void test2() { \n                final int a;     //final空白,在需要的时候才赋值 \n                final int b = 4;    //局部常量--final用于局部变量的情形 \n                final int c;    //final空白,一直没有给赋值.    \n                a = 3; \n                //a=4;    出错,已经给赋过值了. \n                //b=2; 出错,已经给赋过值了. \n        } \n}\n```\n\n4. final参数\n\n> 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。\n\n```java\npublic class Test4 { \n        public static void main(String[] args) { \n                new Test4().f1(2); \n        } \n\n        public void f1(final int i) { \n                //i++;    //i是final类型的,值不允许改变的. \n                System.out.print(i); \n        } \n}\n```\n\n## 1.2 static\n\n> static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。\n>\n>  **被static修饰的成员变量和成员方法独立于该类的任何对象。**也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。\n>\n> **用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。**\n>\n> **static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。**\n>\n> 实际上你需要搞明白，**private是访问权限限定，static表示不要实例化就可以使用，**这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。\n>\n> static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：\n> 类名.静态方法名(参数列表...) \n> 类名.静态变量名\n>\n>         用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块。\n\n1. static变量\n\n>   按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：\n>   ​      对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。\n>   ​      对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。\n\n2. 静态方法\n\n> 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！\n> ​        因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。\n\n3. static代码块\n\n> static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。\n\n```java\npublic class Test5 { \n        private static int a; \n        private int b; \n\n        static { \n                Test5.a = 3; \n                System.out.println(a); \n                Test5 t = new Test5(); \n                t.f(); \n                t.b = 1000; \n                System.out.println(t.b); \n        } \n\n        static { \n                Test5.a = 4; \n                System.out.println(a); \n        } \n\n        public static void main(String[] args) { \n                // TODO 自动生成方法存根 \n        } \n\n        static { \n                Test5.a = 5; \n                System.out.println(a); \n        } \n\n        public void f() { \n                System.out.println(\"hhahhahah\"); \n        } \n}\n```\n\n```java\n运行结果：\n3\nhhahhahah\n1000\n4\n5\n```\n\n>   利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。\n\n4. static和final一块用表示什么\n\n> static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！\n>\n> 1. 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。\n> 2. 对于方法，表示不可覆盖，并且可以通过类名直接访问。 \n>\n>       \n>\n>    **特别要注意一个问题：**\n>\n>         对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。\n\n```java\npublic class TestStaticFinal { \n        private static final String strStaticFinalVar = \"aaa\"; \n        private static String strStaticVar = null; \n        private final String strFinalVar = null; \n        private static final int intStaticFinalVar = 0; \n        private static final Integer integerStaticFinalVar = new Integer(8); \n        private static final ArrayList<String> alStaticFinalVar = new ArrayList<String>(); \n\n        private void test() { \n                System.out.println(\"-------------值处理前----------\\r\\n\"); \n                System.out.println(\"strStaticFinalVar=\" + strStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"strStaticVar=\" + strStaticVar + \"\\r\\n\"); \n                System.out.println(\"strFinalVar=\" + strFinalVar + \"\\r\\n\"); \n                System.out.println(\"intStaticFinalVar=\" + intStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"integerStaticFinalVar=\" + integerStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"alStaticFinalVar=\" + alStaticFinalVar + \"\\r\\n\"); \n\n\n                //strStaticFinalVar=\"哈哈哈哈\";        //错误，final表示终态,不可以改变变量本身. \n                strStaticVar = \"哈哈哈哈\";                //正确，static表示类变量,值可以改变. \n                //strFinalVar=\"呵呵呵呵\";                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                //intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                //integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 \n                alStaticFinalVar.add(\"aaa\");        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 \n                alStaticFinalVar.add(\"bbb\");        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 \n\n                System.out.println(\"-------------值处理后----------\\r\\n\"); \n                System.out.println(\"strStaticFinalVar=\" + strStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"strStaticVar=\" + strStaticVar + \"\\r\\n\"); \n                System.out.println(\"strFinalVar=\" + strFinalVar + \"\\r\\n\"); \n                System.out.println(\"intStaticFinalVar=\" + intStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"integerStaticFinalVar=\" + integerStaticFinalVar + \"\\r\\n\"); \n                System.out.println(\"alStaticFinalVar=\" + alStaticFinalVar + \"\\r\\n\"); \n        } \n\n        public static void main(String args[]) { \n                new TestStaticFinal().test(); \n        } \n}\n```\n\n```java\n运行结果如下：\n-------------值处理前----------\nstrStaticFinalVar=aaa\nstrStaticVar=null\nstrFinalVar=null\nintStaticFinalVar=0\nintegerStaticFinalVar=8\nalStaticFinalVar=[]\n-------------值处理后----------\nstrStaticFinalVar=aaa\nstrStaticVar=哈哈哈哈\nstrFinalVar=null\nintStaticFinalVar=0\nintegerStaticFinalVar=8\nalStaticFinalVar=[aaa, bbb]\n\nProcess finished with exit code 0\n```\n\n# 2. transient关键字\n\n# 3. 对象序列化Serializable和Externalizable\n\n# 4. 持有对象","slug":"死磕java基础","published":1,"updated":"2018-12-28T09:16:18.480Z","layout":"post","photos":[],"link":"","_id":"cjq7zaldf000koos2fovnu0xo","content":"<h1 id=\"1-关键字final和static总结\"><a href=\"#1-关键字final和static总结\" class=\"headerlink\" title=\"1. 关键字final和static总结\"></a>1. 关键字final和static总结</h1><h2 id=\"1-1-final\"><a href=\"#1-1-final\" class=\"headerlink\" title=\"1.1 final\"></a>1.1 final</h2><blockquote>\n<p> 根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。</p>\n<ol>\n<li>final类不能被继承，没有子类，final类中的方法默认是final的。</li>\n<li>final方法不能被子类的方法覆盖，但可以被继承。</li>\n<li>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</li>\n<li>final不能用于修饰构造方法。<br> <strong>注意：</strong>父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的.      </li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<ol>\n<li>final类</li>\n</ol>\n<blockquote>\n<p>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p>\n</blockquote>\n<ol start=\"2\">\n<li>final方法</li>\n</ol>\n<blockquote>\n<p> 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br> 使用final方法的原因有二：</p>\n<ol>\n<li>把方法锁定，防止任何继承类修改它的意义和实现。</li>\n<li>高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。</li>\n</ol>\n</blockquote>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// TODO 自动生成方法存根 </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f1\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//无法被子类覆盖的方法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f2\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f3\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">f4</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f4\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Test1</span> </span>&#123; </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>&#123;     </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Test1父类方法f1被覆盖!\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">    Test2 t=<span class=\"keyword\">new</span> Test2(); </span><br><span class=\"line\">    t.f1();    </span><br><span class=\"line\">    t.f2(); <span class=\"comment\">//调用从父类继承过来的final方法 </span></span><br><span class=\"line\">    t.f3(); <span class=\"comment\">//调用从父类继承过来的方法 </span></span><br><span class=\"line\">    <span class=\"comment\">//t.f4(); //调用失败，无法从父类继承获得 </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>final变量（常量）</li>\n</ol>\n<blockquote>\n<p>用final修饰的成员变量表示常量，值一旦给定就无法改变！<br>​        final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>​        从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。<br>​        另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器  都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test3</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String S = <span class=\"string\">\"final实例变量S\"</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> A = <span class=\"number\">100</span>; </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> B = <span class=\"number\">90</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> C = <span class=\"number\">80</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> D = <span class=\"number\">70</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> E; <span class=\"comment\">//final空白,必须在初始化对象的时候赋初值 </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; </span><br><span class=\"line\">                E = x; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> args </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">                Test3 t = <span class=\"keyword\">new</span> Test3(<span class=\"number\">2</span>); </span><br><span class=\"line\">                <span class=\"comment\">//t.A=101;    //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\">                <span class=\"comment\">//t.B=91; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\">                <span class=\"comment\">//t.C=81; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\">                <span class=\"comment\">//t.D=71; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(t.A); </span><br><span class=\"line\">                System.out.println(t.B); </span><br><span class=\"line\">                System.out.println(t.C); <span class=\"comment\">//不推荐用对象方式访问静态字段 </span></span><br><span class=\"line\">                System.out.println(t.D); <span class=\"comment\">//不推荐用对象方式访问静态字段 </span></span><br><span class=\"line\">                System.out.println(Test3.C); </span><br><span class=\"line\">                System.out.println(Test3.D); </span><br><span class=\"line\">                <span class=\"comment\">//System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. </span></span><br><span class=\"line\">                System.out.println(t.E); </span><br><span class=\"line\"></span><br><span class=\"line\">                Test3 t1 = <span class=\"keyword\">new</span> Test3(<span class=\"number\">3</span>); </span><br><span class=\"line\">                System.out.println(t1.E); <span class=\"comment\">//final空白变量E依据对象的不同而不同 </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">new</span> Test3(<span class=\"number\">1</span>).A); </span><br><span class=\"line\">                System.out.println(Test3.C); </span><br><span class=\"line\">                System.out.println(Test3.D); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> a;     <span class=\"comment\">//final空白,在需要的时候才赋值 </span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> b = <span class=\"number\">4</span>;    <span class=\"comment\">//局部常量--final用于局部变量的情形 </span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> c;    <span class=\"comment\">//final空白,一直没有给赋值.    </span></span><br><span class=\"line\">                a = <span class=\"number\">3</span>; </span><br><span class=\"line\">                <span class=\"comment\">//a=4;    出错,已经给赋过值了. </span></span><br><span class=\"line\">                <span class=\"comment\">//b=2; 出错,已经给赋过值了. </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>final参数</li>\n</ol>\n<blockquote>\n<p>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test4</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">new</span> Test4().f1(<span class=\"number\">2</span>); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i)</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"comment\">//i++;    //i是final类型的,值不允许改变的. </span></span><br><span class=\"line\">                System.out.print(i); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-static\"><a href=\"#1-2-static\" class=\"headerlink\" title=\"1.2 static\"></a>1.2 static</h2><blockquote>\n<p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p>\n<p> <strong>被static修饰的成员变量和成员方法独立于该类的任何对象。</strong>也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>\n<p><strong>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</strong></p>\n<p><strong>static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。</strong></p>\n<p>实际上你需要搞明白，<strong>private是访问权限限定，static表示不要实例化就可以使用，</strong>这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。</p>\n<p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：<br>类名.静态方法名(参数列表…)<br>类名.静态变量名</p>\n<pre><code>用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块。\n</code></pre></blockquote>\n<ol>\n<li>static变量</li>\n</ol>\n<blockquote>\n<p>  按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br>  ​      对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br>  ​      对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</p>\n</blockquote>\n<ol start=\"2\">\n<li>静态方法</li>\n</ol>\n<blockquote>\n<p>静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！<br>​        因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>\n</blockquote>\n<ol start=\"3\">\n<li>static代码块</li>\n</ol>\n<blockquote>\n<p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test5</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">                Test5.a = <span class=\"number\">3</span>; </span><br><span class=\"line\">                System.out.println(a); </span><br><span class=\"line\">                Test5 t = <span class=\"keyword\">new</span> Test5(); </span><br><span class=\"line\">                t.f(); </span><br><span class=\"line\">                t.b = <span class=\"number\">1000</span>; </span><br><span class=\"line\">                System.out.println(t.b); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">                Test5.a = <span class=\"number\">4</span>; </span><br><span class=\"line\">                System.out.println(a); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"comment\">// TODO 自动生成方法存根 </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">                Test5.a = <span class=\"number\">5</span>; </span><br><span class=\"line\">                System.out.println(a); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"hhahhahah\"</span>); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">运行结果：</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">hhahhahah</span><br><span class=\"line\"><span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>  利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。</p>\n</blockquote>\n<ol start=\"4\">\n<li>static和final一块用表示什么</li>\n</ol>\n<blockquote>\n<p>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！</p>\n<ol>\n<li>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。</li>\n<li>对于方法，表示不可覆盖，并且可以通过类名直接访问。 </li>\n</ol>\n<p>   <strong>特别要注意一个问题：</strong></p>\n<pre><code>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。\n</code></pre></blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestStaticFinal</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String strStaticFinalVar = <span class=\"string\">\"aaa\"</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String strStaticVar = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String strFinalVar = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> intStaticFinalVar = <span class=\"number\">0</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer integerStaticFinalVar = <span class=\"keyword\">new</span> Integer(<span class=\"number\">8</span>); </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ArrayList&lt;String&gt; alStaticFinalVar = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;(); </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"-------------值处理前----------\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticFinalVar=\"</span> + strStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticVar=\"</span> + strStaticVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strFinalVar=\"</span> + strFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"intStaticFinalVar=\"</span> + intStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"integerStaticFinalVar=\"</span> + integerStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"alStaticFinalVar=\"</span> + alStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//strStaticFinalVar=\"哈哈哈哈\";        //错误，final表示终态,不可以改变变量本身. </span></span><br><span class=\"line\">                strStaticVar = <span class=\"string\">\"哈哈哈哈\"</span>;                <span class=\"comment\">//正确，static表示类变量,值可以改变. </span></span><br><span class=\"line\">                <span class=\"comment\">//strFinalVar=\"呵呵呵呵\";                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 </span></span><br><span class=\"line\">                <span class=\"comment\">//intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 </span></span><br><span class=\"line\">                <span class=\"comment\">//integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 </span></span><br><span class=\"line\">                alStaticFinalVar.add(<span class=\"string\">\"aaa\"</span>);        <span class=\"comment\">//正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 </span></span><br><span class=\"line\">                alStaticFinalVar.add(<span class=\"string\">\"bbb\"</span>);        <span class=\"comment\">//正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 </span></span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"-------------值处理后----------\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticFinalVar=\"</span> + strStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticVar=\"</span> + strStaticVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strFinalVar=\"</span> + strFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"intStaticFinalVar=\"</span> + intStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"integerStaticFinalVar=\"</span> + integerStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"alStaticFinalVar=\"</span> + alStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">new</span> TestStaticFinal().test(); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">运行结果如下：</span><br><span class=\"line\">-------------值处理前----------</span><br><span class=\"line\">strStaticFinalVar=aaa</span><br><span class=\"line\">strStaticVar=<span class=\"keyword\">null</span></span><br><span class=\"line\">strFinalVar=<span class=\"keyword\">null</span></span><br><span class=\"line\">intStaticFinalVar=<span class=\"number\">0</span></span><br><span class=\"line\">integerStaticFinalVar=<span class=\"number\">8</span></span><br><span class=\"line\">alStaticFinalVar=[]</span><br><span class=\"line\">-------------值处理后----------</span><br><span class=\"line\">strStaticFinalVar=aaa</span><br><span class=\"line\">strStaticVar=哈哈哈哈</span><br><span class=\"line\">strFinalVar=<span class=\"keyword\">null</span></span><br><span class=\"line\">intStaticFinalVar=<span class=\"number\">0</span></span><br><span class=\"line\">integerStaticFinalVar=<span class=\"number\">8</span></span><br><span class=\"line\">alStaticFinalVar=[aaa, bbb]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"2-transient关键字\"><a href=\"#2-transient关键字\" class=\"headerlink\" title=\"2. transient关键字\"></a>2. transient关键字</h1><h1 id=\"3-对象序列化Serializable和Externalizable\"><a href=\"#3-对象序列化Serializable和Externalizable\" class=\"headerlink\" title=\"3. 对象序列化Serializable和Externalizable\"></a>3. 对象序列化Serializable和Externalizable</h1><h1 id=\"4-持有对象\"><a href=\"#4-持有对象\" class=\"headerlink\" title=\"4. 持有对象\"></a>4. 持有对象</h1>","site":{"data":{}},"excerpt":"<h1 id=\"1-关键字final和static总结\"><a href=\"#1-关键字final和static总结\" class=\"headerlink\" title=\"1. 关键字final和static总结\"></a>1. 关键字final和static总结</h1><h2 id=\"1-1-final\"><a href=\"#1-1-final\" class=\"headerlink\" title=\"1.1 final\"></a>1.1 final</h2><blockquote>\n<p> 根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。</p>\n<ol>\n<li>final类不能被继承，没有子类，final类中的方法默认是final的。</li>\n<li>final方法不能被子类的方法覆盖，但可以被继承。</li>\n<li>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</li>\n<li>final不能用于修饰构造方法。<br> <strong>注意：</strong>父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的.      </li>\n</ol>\n</blockquote>","more":"<ol>\n<li>final类</li>\n</ol>\n<blockquote>\n<p>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p>\n</blockquote>\n<ol start=\"2\">\n<li>final方法</li>\n</ol>\n<blockquote>\n<p> 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br> 使用final方法的原因有二：</p>\n<ol>\n<li>把方法锁定，防止任何继承类修改它的意义和实现。</li>\n<li>高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。</li>\n</ol>\n</blockquote>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// TODO 自动生成方法存根 </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f1\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//无法被子类覆盖的方法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f2\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f3\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">f4</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"f4\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Test1</span> </span>&#123; </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>&#123;     </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Test1父类方法f1被覆盖!\"</span>); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">    Test2 t=<span class=\"keyword\">new</span> Test2(); </span><br><span class=\"line\">    t.f1();    </span><br><span class=\"line\">    t.f2(); <span class=\"comment\">//调用从父类继承过来的final方法 </span></span><br><span class=\"line\">    t.f3(); <span class=\"comment\">//调用从父类继承过来的方法 </span></span><br><span class=\"line\">    <span class=\"comment\">//t.f4(); //调用失败，无法从父类继承获得 </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>final变量（常量）</li>\n</ol>\n<blockquote>\n<p>用final修饰的成员变量表示常量，值一旦给定就无法改变！<br>​        final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>​        从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。<br>​        另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器  都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test3</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String S = <span class=\"string\">\"final实例变量S\"</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> A = <span class=\"number\">100</span>; </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> B = <span class=\"number\">90</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> C = <span class=\"number\">80</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> D = <span class=\"number\">70</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> E; <span class=\"comment\">//final空白,必须在初始化对象的时候赋初值 </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test3</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123; </span><br><span class=\"line\">                E = x; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> args </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">                Test3 t = <span class=\"keyword\">new</span> Test3(<span class=\"number\">2</span>); </span><br><span class=\"line\">                <span class=\"comment\">//t.A=101;    //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\">                <span class=\"comment\">//t.B=91; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\">                <span class=\"comment\">//t.C=81; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\">                <span class=\"comment\">//t.D=71; //出错,final变量的值一旦给定就无法改变 </span></span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(t.A); </span><br><span class=\"line\">                System.out.println(t.B); </span><br><span class=\"line\">                System.out.println(t.C); <span class=\"comment\">//不推荐用对象方式访问静态字段 </span></span><br><span class=\"line\">                System.out.println(t.D); <span class=\"comment\">//不推荐用对象方式访问静态字段 </span></span><br><span class=\"line\">                System.out.println(Test3.C); </span><br><span class=\"line\">                System.out.println(Test3.D); </span><br><span class=\"line\">                <span class=\"comment\">//System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. </span></span><br><span class=\"line\">                System.out.println(t.E); </span><br><span class=\"line\"></span><br><span class=\"line\">                Test3 t1 = <span class=\"keyword\">new</span> Test3(<span class=\"number\">3</span>); </span><br><span class=\"line\">                System.out.println(t1.E); <span class=\"comment\">//final空白变量E依据对象的不同而不同 </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">new</span> Test3(<span class=\"number\">1</span>).A); </span><br><span class=\"line\">                System.out.println(Test3.C); </span><br><span class=\"line\">                System.out.println(Test3.D); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> a;     <span class=\"comment\">//final空白,在需要的时候才赋值 </span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> b = <span class=\"number\">4</span>;    <span class=\"comment\">//局部常量--final用于局部变量的情形 </span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> c;    <span class=\"comment\">//final空白,一直没有给赋值.    </span></span><br><span class=\"line\">                a = <span class=\"number\">3</span>; </span><br><span class=\"line\">                <span class=\"comment\">//a=4;    出错,已经给赋过值了. </span></span><br><span class=\"line\">                <span class=\"comment\">//b=2; 出错,已经给赋过值了. </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>final参数</li>\n</ol>\n<blockquote>\n<p>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test4</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">new</span> Test4().f1(<span class=\"number\">2</span>); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i)</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"comment\">//i++;    //i是final类型的,值不允许改变的. </span></span><br><span class=\"line\">                System.out.print(i); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-static\"><a href=\"#1-2-static\" class=\"headerlink\" title=\"1.2 static\"></a>1.2 static</h2><blockquote>\n<p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p>\n<p> <strong>被static修饰的成员变量和成员方法独立于该类的任何对象。</strong>也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>\n<p><strong>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</strong></p>\n<p><strong>static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。</strong></p>\n<p>实际上你需要搞明白，<strong>private是访问权限限定，static表示不要实例化就可以使用，</strong>这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。</p>\n<p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：<br>类名.静态方法名(参数列表…)<br>类名.静态变量名</p>\n<pre><code>用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块。\n</code></pre></blockquote>\n<ol>\n<li>static变量</li>\n</ol>\n<blockquote>\n<p>  按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br>  ​      对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br>  ​      对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</p>\n</blockquote>\n<ol start=\"2\">\n<li>静态方法</li>\n</ol>\n<blockquote>\n<p>静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！<br>​        因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>\n</blockquote>\n<ol start=\"3\">\n<li>static代码块</li>\n</ol>\n<blockquote>\n<p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test5</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">                Test5.a = <span class=\"number\">3</span>; </span><br><span class=\"line\">                System.out.println(a); </span><br><span class=\"line\">                Test5 t = <span class=\"keyword\">new</span> Test5(); </span><br><span class=\"line\">                t.f(); </span><br><span class=\"line\">                t.b = <span class=\"number\">1000</span>; </span><br><span class=\"line\">                System.out.println(t.b); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">                Test5.a = <span class=\"number\">4</span>; </span><br><span class=\"line\">                System.out.println(a); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"comment\">// TODO 自动生成方法存根 </span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">                Test5.a = <span class=\"number\">5</span>; </span><br><span class=\"line\">                System.out.println(a); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"hhahhahah\"</span>); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">运行结果：</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">hhahhahah</span><br><span class=\"line\"><span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>  利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。</p>\n</blockquote>\n<ol start=\"4\">\n<li>static和final一块用表示什么</li>\n</ol>\n<blockquote>\n<p>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！</p>\n<ol>\n<li>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。</li>\n<li>对于方法，表示不可覆盖，并且可以通过类名直接访问。 </li>\n</ol>\n<p>   <strong>特别要注意一个问题：</strong></p>\n<pre><code>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。\n</code></pre></blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestStaticFinal</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String strStaticFinalVar = <span class=\"string\">\"aaa\"</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String strStaticVar = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String strFinalVar = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> intStaticFinalVar = <span class=\"number\">0</span>; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer integerStaticFinalVar = <span class=\"keyword\">new</span> Integer(<span class=\"number\">8</span>); </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ArrayList&lt;String&gt; alStaticFinalVar = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;(); </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"-------------值处理前----------\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticFinalVar=\"</span> + strStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticVar=\"</span> + strStaticVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strFinalVar=\"</span> + strFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"intStaticFinalVar=\"</span> + intStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"integerStaticFinalVar=\"</span> + integerStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"alStaticFinalVar=\"</span> + alStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//strStaticFinalVar=\"哈哈哈哈\";        //错误，final表示终态,不可以改变变量本身. </span></span><br><span class=\"line\">                strStaticVar = <span class=\"string\">\"哈哈哈哈\"</span>;                <span class=\"comment\">//正确，static表示类变量,值可以改变. </span></span><br><span class=\"line\">                <span class=\"comment\">//strFinalVar=\"呵呵呵呵\";                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 </span></span><br><span class=\"line\">                <span class=\"comment\">//intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 </span></span><br><span class=\"line\">                <span class=\"comment\">//integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 </span></span><br><span class=\"line\">                alStaticFinalVar.add(<span class=\"string\">\"aaa\"</span>);        <span class=\"comment\">//正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 </span></span><br><span class=\"line\">                alStaticFinalVar.add(<span class=\"string\">\"bbb\"</span>);        <span class=\"comment\">//正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 </span></span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"-------------值处理后----------\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticFinalVar=\"</span> + strStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strStaticVar=\"</span> + strStaticVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"strFinalVar=\"</span> + strFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"intStaticFinalVar=\"</span> + intStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"integerStaticFinalVar=\"</span> + integerStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"alStaticFinalVar=\"</span> + alStaticFinalVar + <span class=\"string\">\"\\r\\n\"</span>); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">new</span> TestStaticFinal().test(); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">运行结果如下：</span><br><span class=\"line\">-------------值处理前----------</span><br><span class=\"line\">strStaticFinalVar=aaa</span><br><span class=\"line\">strStaticVar=<span class=\"keyword\">null</span></span><br><span class=\"line\">strFinalVar=<span class=\"keyword\">null</span></span><br><span class=\"line\">intStaticFinalVar=<span class=\"number\">0</span></span><br><span class=\"line\">integerStaticFinalVar=<span class=\"number\">8</span></span><br><span class=\"line\">alStaticFinalVar=[]</span><br><span class=\"line\">-------------值处理后----------</span><br><span class=\"line\">strStaticFinalVar=aaa</span><br><span class=\"line\">strStaticVar=哈哈哈哈</span><br><span class=\"line\">strFinalVar=<span class=\"keyword\">null</span></span><br><span class=\"line\">intStaticFinalVar=<span class=\"number\">0</span></span><br><span class=\"line\">integerStaticFinalVar=<span class=\"number\">8</span></span><br><span class=\"line\">alStaticFinalVar=[aaa, bbb]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"2-transient关键字\"><a href=\"#2-transient关键字\" class=\"headerlink\" title=\"2. transient关键字\"></a>2. transient关键字</h1><h1 id=\"3-对象序列化Serializable和Externalizable\"><a href=\"#3-对象序列化Serializable和Externalizable\" class=\"headerlink\" title=\"3. 对象序列化Serializable和Externalizable\"></a>3. 对象序列化Serializable和Externalizable</h1><h1 id=\"4-持有对象\"><a href=\"#4-持有对象\" class=\"headerlink\" title=\"4. 持有对象\"></a>4. 持有对象</h1>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjq7zalbv0000oos22002xb8f","category_id":"cjq7zalca0004oos245ke5ise","_id":"cjq7zalcr000eoos287enjz1y"},{"post_id":"cjq7zalc50002oos2d0o7k8kb","category_id":"cjq7zalca0004oos245ke5ise","_id":"cjq7zalcu000hoos2py8b7pu5"},{"post_id":"cjq7zalce0006oos2x27h3wcg","category_id":"cjq7zalca0004oos245ke5ise","_id":"cjq7zalcw000joos2ynjo1idd"},{"post_id":"cjq7zaldf000koos2fovnu0xo","category_id":"cjq7zalca0004oos245ke5ise","_id":"cjq7zaldk000moos27s4lnm8n"}],"PostTag":[{"post_id":"cjq7zalbv0000oos22002xb8f","tag_id":"cjq7zalcd0005oos2zq29lbio","_id":"cjq7zalcp000coos2s0h0dxpe"},{"post_id":"cjq7zalc50002oos2d0o7k8kb","tag_id":"cjq7zalcm000aoos2gvn185we","_id":"cjq7zalct000goos2tytshibs"},{"post_id":"cjq7zalce0006oos2x27h3wcg","tag_id":"cjq7zalcs000foos2dw9mx2kt","_id":"cjq7zalcv000ioos26sxnswwo"},{"post_id":"cjq7zaldf000koos2fovnu0xo","tag_id":"cjq7zaldj000loos2az8ip55w","_id":"cjq7zaldl000noos2cbvfqhnm"}],"Tag":[{"name":"mybatis","_id":"cjq7zalcd0005oos2zq29lbio"},{"name":"springmvc","_id":"cjq7zalcm000aoos2gvn185we"},{"name":"springboot","_id":"cjq7zalcs000foos2dw9mx2kt"},{"name":"java基础","_id":"cjq7zaldj000loos2az8ip55w"}]}}